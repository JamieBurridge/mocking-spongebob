{"mappings":"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","sources":["<anon>","src/scripts/main.js","node_modules/html-to-image/es/index.js","node_modules/html-to-image/src/index.ts","node_modules/html-to-image/es/clone-node.js","node_modules/html-to-image/src/clone-node.ts","node_modules/html-to-image/es/clone-pseudos.js","node_modules/html-to-image/src/clone-pseudos.ts","node_modules/html-to-image/es/util.js","node_modules/html-to-image/src/util.ts","node_modules/process/browser.js","node_modules/html-to-image/es/mimes.js","node_modules/html-to-image/src/mimes.ts","node_modules/html-to-image/es/dataurl.js","node_modules/html-to-image/src/dataurl.ts","node_modules/html-to-image/es/embed-images.js","node_modules/html-to-image/src/embed-images.ts","node_modules/html-to-image/es/embed-resources.js","node_modules/html-to-image/src/embed-resources.ts","node_modules/html-to-image/es/apply-style.js","node_modules/html-to-image/src/apply-style.ts","node_modules/html-to-image/es/embed-webfonts.js","node_modules/html-to-image/src/embed-webfonts.ts","node_modules/file-saver/dist/FileSaver.min.js","node_modules/file-saver/src/FileSaver.js"],"sourcesContent":["\n      var $parcel$global = globalThis;\n    var $cfae44f0dfdf62c0$exports = {};\n// shim for using process in browser\nvar $cfae44f0dfdf62c0$var$process = $cfae44f0dfdf62c0$exports = {};\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar $cfae44f0dfdf62c0$var$cachedSetTimeout;\nvar $cfae44f0dfdf62c0$var$cachedClearTimeout;\nfunction $cfae44f0dfdf62c0$var$defaultSetTimout() {\n    throw new Error(\"setTimeout has not been defined\");\n}\nfunction $cfae44f0dfdf62c0$var$defaultClearTimeout() {\n    throw new Error(\"clearTimeout has not been defined\");\n}\n(function() {\n    try {\n        if (typeof setTimeout === \"function\") $cfae44f0dfdf62c0$var$cachedSetTimeout = setTimeout;\n        else $cfae44f0dfdf62c0$var$cachedSetTimeout = $cfae44f0dfdf62c0$var$defaultSetTimout;\n    } catch (e) {\n        $cfae44f0dfdf62c0$var$cachedSetTimeout = $cfae44f0dfdf62c0$var$defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === \"function\") $cfae44f0dfdf62c0$var$cachedClearTimeout = clearTimeout;\n        else $cfae44f0dfdf62c0$var$cachedClearTimeout = $cfae44f0dfdf62c0$var$defaultClearTimeout;\n    } catch (e) {\n        $cfae44f0dfdf62c0$var$cachedClearTimeout = $cfae44f0dfdf62c0$var$defaultClearTimeout;\n    }\n})();\nfunction $cfae44f0dfdf62c0$var$runTimeout(fun) {\n    if ($cfae44f0dfdf62c0$var$cachedSetTimeout === setTimeout) //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n    // if setTimeout wasn't available but was latter defined\n    if (($cfae44f0dfdf62c0$var$cachedSetTimeout === $cfae44f0dfdf62c0$var$defaultSetTimout || !$cfae44f0dfdf62c0$var$cachedSetTimeout) && setTimeout) {\n        $cfae44f0dfdf62c0$var$cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $cfae44f0dfdf62c0$var$cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return $cfae44f0dfdf62c0$var$cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return $cfae44f0dfdf62c0$var$cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction $cfae44f0dfdf62c0$var$runClearTimeout(marker) {\n    if ($cfae44f0dfdf62c0$var$cachedClearTimeout === clearTimeout) //normal enviroments in sane situations\n    return clearTimeout(marker);\n    // if clearTimeout wasn't available but was latter defined\n    if (($cfae44f0dfdf62c0$var$cachedClearTimeout === $cfae44f0dfdf62c0$var$defaultClearTimeout || !$cfae44f0dfdf62c0$var$cachedClearTimeout) && clearTimeout) {\n        $cfae44f0dfdf62c0$var$cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $cfae44f0dfdf62c0$var$cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return $cfae44f0dfdf62c0$var$cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return $cfae44f0dfdf62c0$var$cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar $cfae44f0dfdf62c0$var$queue = [];\nvar $cfae44f0dfdf62c0$var$draining = false;\nvar $cfae44f0dfdf62c0$var$currentQueue;\nvar $cfae44f0dfdf62c0$var$queueIndex = -1;\nfunction $cfae44f0dfdf62c0$var$cleanUpNextTick() {\n    if (!$cfae44f0dfdf62c0$var$draining || !$cfae44f0dfdf62c0$var$currentQueue) return;\n    $cfae44f0dfdf62c0$var$draining = false;\n    if ($cfae44f0dfdf62c0$var$currentQueue.length) $cfae44f0dfdf62c0$var$queue = $cfae44f0dfdf62c0$var$currentQueue.concat($cfae44f0dfdf62c0$var$queue);\n    else $cfae44f0dfdf62c0$var$queueIndex = -1;\n    if ($cfae44f0dfdf62c0$var$queue.length) $cfae44f0dfdf62c0$var$drainQueue();\n}\nfunction $cfae44f0dfdf62c0$var$drainQueue() {\n    if ($cfae44f0dfdf62c0$var$draining) return;\n    var timeout = $cfae44f0dfdf62c0$var$runTimeout($cfae44f0dfdf62c0$var$cleanUpNextTick);\n    $cfae44f0dfdf62c0$var$draining = true;\n    var len = $cfae44f0dfdf62c0$var$queue.length;\n    while(len){\n        $cfae44f0dfdf62c0$var$currentQueue = $cfae44f0dfdf62c0$var$queue;\n        $cfae44f0dfdf62c0$var$queue = [];\n        while(++$cfae44f0dfdf62c0$var$queueIndex < len)if ($cfae44f0dfdf62c0$var$currentQueue) $cfae44f0dfdf62c0$var$currentQueue[$cfae44f0dfdf62c0$var$queueIndex].run();\n        $cfae44f0dfdf62c0$var$queueIndex = -1;\n        len = $cfae44f0dfdf62c0$var$queue.length;\n    }\n    $cfae44f0dfdf62c0$var$currentQueue = null;\n    $cfae44f0dfdf62c0$var$draining = false;\n    $cfae44f0dfdf62c0$var$runClearTimeout(timeout);\n}\n$cfae44f0dfdf62c0$var$process.nextTick = function(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];\n    $cfae44f0dfdf62c0$var$queue.push(new $cfae44f0dfdf62c0$var$Item(fun, args));\n    if ($cfae44f0dfdf62c0$var$queue.length === 1 && !$cfae44f0dfdf62c0$var$draining) $cfae44f0dfdf62c0$var$runTimeout($cfae44f0dfdf62c0$var$drainQueue);\n};\n// v8 likes predictible objects\nfunction $cfae44f0dfdf62c0$var$Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\n$cfae44f0dfdf62c0$var$Item.prototype.run = function() {\n    this.fun.apply(null, this.array);\n};\n$cfae44f0dfdf62c0$var$process.title = \"browser\";\n$cfae44f0dfdf62c0$var$process.browser = true;\n$cfae44f0dfdf62c0$var$process.env = {};\n$cfae44f0dfdf62c0$var$process.argv = [];\n$cfae44f0dfdf62c0$var$process.version = \"\"; // empty string to avoid regexp issues\n$cfae44f0dfdf62c0$var$process.versions = {};\nfunction $cfae44f0dfdf62c0$var$noop() {}\n$cfae44f0dfdf62c0$var$process.on = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.addListener = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.once = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.off = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.removeListener = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.removeAllListeners = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.emit = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.prependListener = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.prependOnceListener = $cfae44f0dfdf62c0$var$noop;\n$cfae44f0dfdf62c0$var$process.listeners = function(name) {\n    return [];\n};\n$cfae44f0dfdf62c0$var$process.binding = function(name) {\n    throw new Error(\"process.binding is not supported\");\n};\n$cfae44f0dfdf62c0$var$process.cwd = function() {\n    return \"/\";\n};\n$cfae44f0dfdf62c0$var$process.chdir = function(dir) {\n    throw new Error(\"process.chdir is not supported\");\n};\n$cfae44f0dfdf62c0$var$process.umask = function() {\n    return 0;\n};\n\n\nfunction $9eb70742a7095e98$export$f85c16a6d62f7d63(url, baseUrl) {\n    // url is absolute already\n    if (url.match(/^[a-z]+:\\/\\//i)) return url;\n    // url is absolute already, without protocol\n    if (url.match(/^\\/\\//)) return window.location.protocol + url;\n    // dataURI, mailto:, tel:, etc.\n    if (url.match(/^[a-z]+:/i)) return url;\n    const doc = document.implementation.createHTMLDocument();\n    const base = doc.createElement(\"base\");\n    const a = doc.createElement(\"a\");\n    doc.head.appendChild(base);\n    doc.body.appendChild(a);\n    if (baseUrl) base.href = baseUrl;\n    a.href = url;\n    return a.href;\n}\nconst $9eb70742a7095e98$export$31b40729666a4ae0 = (()=>{\n    // generate uuid for className of pseudo elements.\n    // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.\n    let counter = 0;\n    // ref: http://stackoverflow.com/a/6248722/2519373\n    const random = ()=>// eslint-disable-next-line no-bitwise\n        `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4);\n    return ()=>{\n        counter += 1;\n        return `u${random()}${counter}`;\n    };\n})();\nfunction $9eb70742a7095e98$export$1391212d75b2ee65(ms) {\n    return (args)=>new Promise((resolve)=>{\n            setTimeout(()=>resolve(args), ms);\n        });\n}\nfunction $9eb70742a7095e98$export$45b10814cc054894(arrayLike) {\n    const arr = [];\n    for(let i = 0, l = arrayLike.length; i < l; i++)arr.push(arrayLike[i]);\n    return arr;\n}\nfunction $9eb70742a7095e98$var$px(node, styleProperty) {\n    const win = node.ownerDocument.defaultView || window;\n    const val = win.getComputedStyle(node).getPropertyValue(styleProperty);\n    return val ? parseFloat(val.replace(\"px\", \"\")) : 0;\n}\nfunction $9eb70742a7095e98$var$getNodeWidth(node) {\n    const leftBorder = $9eb70742a7095e98$var$px(node, \"border-left-width\");\n    const rightBorder = $9eb70742a7095e98$var$px(node, \"border-right-width\");\n    return node.clientWidth + leftBorder + rightBorder;\n}\nfunction $9eb70742a7095e98$var$getNodeHeight(node) {\n    const topBorder = $9eb70742a7095e98$var$px(node, \"border-top-width\");\n    const bottomBorder = $9eb70742a7095e98$var$px(node, \"border-bottom-width\");\n    return node.clientHeight + topBorder + bottomBorder;\n}\nfunction $9eb70742a7095e98$export$ada5537b2c061996(targetNode, options = {}) {\n    const width = options.width || $9eb70742a7095e98$var$getNodeWidth(targetNode);\n    const height = options.height || $9eb70742a7095e98$var$getNodeHeight(targetNode);\n    return {\n        width: width,\n        height: height\n    };\n}\nfunction $9eb70742a7095e98$export$d39ce20a37bba061() {\n    let ratio;\n    let FINAL_PROCESS;\n    try {\n        FINAL_PROCESS = $cfae44f0dfdf62c0$exports;\n    } catch (e) {\n    // pass\n    }\n    const val = FINAL_PROCESS && FINAL_PROCESS.env ? FINAL_PROCESS.env.devicePixelRatio : null;\n    if (val) {\n        ratio = parseInt(val, 10);\n        if (Number.isNaN(ratio)) ratio = 1;\n    }\n    return ratio || window.devicePixelRatio || 1;\n}\n// @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\nconst $9eb70742a7095e98$var$canvasDimensionLimit = 16384;\nfunction $9eb70742a7095e98$export$c2c809a2fe6b0f1a(canvas) {\n    if (canvas.width > $9eb70742a7095e98$var$canvasDimensionLimit || canvas.height > $9eb70742a7095e98$var$canvasDimensionLimit) {\n        if (canvas.width > $9eb70742a7095e98$var$canvasDimensionLimit && canvas.height > $9eb70742a7095e98$var$canvasDimensionLimit) {\n            if (canvas.width > canvas.height) {\n                canvas.height *= $9eb70742a7095e98$var$canvasDimensionLimit / canvas.width;\n                canvas.width = $9eb70742a7095e98$var$canvasDimensionLimit;\n            } else {\n                canvas.width *= $9eb70742a7095e98$var$canvasDimensionLimit / canvas.height;\n                canvas.height = $9eb70742a7095e98$var$canvasDimensionLimit;\n            }\n        } else if (canvas.width > $9eb70742a7095e98$var$canvasDimensionLimit) {\n            canvas.height *= $9eb70742a7095e98$var$canvasDimensionLimit / canvas.width;\n            canvas.width = $9eb70742a7095e98$var$canvasDimensionLimit;\n        } else {\n            canvas.width *= $9eb70742a7095e98$var$canvasDimensionLimit / canvas.height;\n            canvas.height = $9eb70742a7095e98$var$canvasDimensionLimit;\n        }\n    }\n}\nfunction $9eb70742a7095e98$export$403d539f215df596(canvas, options = {}) {\n    if (canvas.toBlob) return new Promise((resolve)=>{\n        canvas.toBlob(resolve, options.type ? options.type : \"image/png\", options.quality ? options.quality : 1);\n    });\n    return new Promise((resolve)=>{\n        const binaryString = window.atob(canvas.toDataURL(options.type ? options.type : undefined, options.quality ? options.quality : undefined).split(\",\")[1]);\n        const len = binaryString.length;\n        const binaryArray = new Uint8Array(len);\n        for(let i = 0; i < len; i += 1)binaryArray[i] = binaryString.charCodeAt(i);\n        resolve(new Blob([\n            binaryArray\n        ], {\n            type: options.type ? options.type : \"image/png\"\n        }));\n    });\n}\nfunction $9eb70742a7095e98$export$ec664d7487540b(url) {\n    return new Promise((resolve, reject)=>{\n        const img = new Image();\n        img.decode = ()=>resolve(img);\n        img.onload = ()=>resolve(img);\n        img.onerror = reject;\n        img.crossOrigin = \"anonymous\";\n        img.decoding = \"async\";\n        img.src = url;\n    });\n}\nasync function $9eb70742a7095e98$export$fe77aa9c02de4599(svg) {\n    return Promise.resolve().then(()=>new XMLSerializer().serializeToString(svg)).then(encodeURIComponent).then((html)=>`data:image/svg+xml;charset=utf-8,${html}`);\n}\nasync function $9eb70742a7095e98$export$b62810fb8ca515fa(node, width, height) {\n    const xmlns = \"http://www.w3.org/2000/svg\";\n    const svg = document.createElementNS(xmlns, \"svg\");\n    const foreignObject = document.createElementNS(xmlns, \"foreignObject\");\n    svg.setAttribute(\"width\", `${width}`);\n    svg.setAttribute(\"height\", `${height}`);\n    svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n    foreignObject.setAttribute(\"width\", \"100%\");\n    foreignObject.setAttribute(\"height\", \"100%\");\n    foreignObject.setAttribute(\"x\", \"0\");\n    foreignObject.setAttribute(\"y\", \"0\");\n    foreignObject.setAttribute(\"externalResourcesRequired\", \"true\");\n    svg.appendChild(foreignObject);\n    foreignObject.appendChild(node);\n    return $9eb70742a7095e98$export$fe77aa9c02de4599(svg);\n}\nconst $9eb70742a7095e98$export$3a92fc9ec83ef360 = (node, instance)=>{\n    if (node instanceof instance) return true;\n    const nodePrototype = Object.getPrototypeOf(node);\n    if (nodePrototype === null) return false;\n    return nodePrototype.constructor.name === instance.name || $9eb70742a7095e98$export$3a92fc9ec83ef360(nodePrototype, instance);\n};\n\n\nfunction $f1d3d4da19ace37e$var$formatCSSText(style) {\n    const content = style.getPropertyValue(\"content\");\n    return `${style.cssText} content: '${content.replace(/'|\"/g, \"\")}';`;\n}\nfunction $f1d3d4da19ace37e$var$formatCSSProperties(style) {\n    return (0, $9eb70742a7095e98$export$45b10814cc054894)(style).map((name)=>{\n        const value = style.getPropertyValue(name);\n        const priority = style.getPropertyPriority(name);\n        return `${name}: ${value}${priority ? \" !important\" : \"\"};`;\n    }).join(\" \");\n}\nfunction $f1d3d4da19ace37e$var$getPseudoElementStyle(className, pseudo, style) {\n    const selector = `.${className}:${pseudo}`;\n    const cssText = style.cssText ? $f1d3d4da19ace37e$var$formatCSSText(style) : $f1d3d4da19ace37e$var$formatCSSProperties(style);\n    return document.createTextNode(`${selector}{${cssText}}`);\n}\nfunction $f1d3d4da19ace37e$var$clonePseudoElement(nativeNode, clonedNode, pseudo) {\n    const style = window.getComputedStyle(nativeNode, pseudo);\n    const content = style.getPropertyValue(\"content\");\n    if (content === \"\" || content === \"none\") return;\n    const className = (0, $9eb70742a7095e98$export$31b40729666a4ae0)();\n    try {\n        clonedNode.className = `${clonedNode.className} ${className}`;\n    } catch (err) {\n        return;\n    }\n    const styleElement = document.createElement(\"style\");\n    styleElement.appendChild($f1d3d4da19ace37e$var$getPseudoElementStyle(className, pseudo, style));\n    clonedNode.appendChild(styleElement);\n}\nfunction $f1d3d4da19ace37e$export$8df63687a708ed2e(nativeNode, clonedNode) {\n    $f1d3d4da19ace37e$var$clonePseudoElement(nativeNode, clonedNode, \":before\");\n    $f1d3d4da19ace37e$var$clonePseudoElement(nativeNode, clonedNode, \":after\");\n}\n\n\n\nconst $67e830aaea99e7b5$var$WOFF = \"application/font-woff\";\nconst $67e830aaea99e7b5$var$JPEG = \"image/jpeg\";\nconst $67e830aaea99e7b5$var$mimes = {\n    woff: $67e830aaea99e7b5$var$WOFF,\n    woff2: $67e830aaea99e7b5$var$WOFF,\n    ttf: \"application/font-truetype\",\n    eot: \"application/vnd.ms-fontobject\",\n    png: \"image/png\",\n    jpg: $67e830aaea99e7b5$var$JPEG,\n    jpeg: $67e830aaea99e7b5$var$JPEG,\n    gif: \"image/gif\",\n    tiff: \"image/tiff\",\n    svg: \"image/svg+xml\",\n    webp: \"image/webp\"\n};\nfunction $67e830aaea99e7b5$var$getExtension(url) {\n    const match = /\\.([^./]*?)$/g.exec(url);\n    return match ? match[1] : \"\";\n}\nfunction $67e830aaea99e7b5$export$200548c990602f61(url) {\n    const extension = $67e830aaea99e7b5$var$getExtension(url).toLowerCase();\n    return $67e830aaea99e7b5$var$mimes[extension] || \"\";\n}\n\n\nfunction $fd9aaa441bfc2baf$var$getContentFromDataUrl(dataURL) {\n    return dataURL.split(/,/)[1];\n}\nfunction $fd9aaa441bfc2baf$export$f8a05efa20ffd5a(url) {\n    return url.search(/^(data:)/) !== -1;\n}\nfunction $fd9aaa441bfc2baf$export$68336ea1617fa80a(content, mimeType) {\n    return `data:${mimeType};base64,${content}`;\n}\nasync function $fd9aaa441bfc2baf$export$c20a8b76c95b0d41(url, init, process) {\n    const res = await fetch(url, init);\n    if (res.status === 404) throw new Error(`Resource \"${res.url}\" not found`);\n    const blob = await res.blob();\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = ()=>{\n            try {\n                resolve(process({\n                    res: res,\n                    result: reader.result\n                }));\n            } catch (error) {\n                reject(error);\n            }\n        };\n        reader.readAsDataURL(blob);\n    });\n}\nconst $fd9aaa441bfc2baf$var$cache = {};\nfunction $fd9aaa441bfc2baf$var$getCacheKey(url, contentType, includeQueryParams) {\n    let key = url.replace(/\\?.*/, \"\");\n    if (includeQueryParams) key = url;\n    // font resource\n    if (/ttf|otf|eot|woff2?/i.test(key)) key = key.replace(/.*\\//, \"\");\n    return contentType ? `[${contentType}]${key}` : key;\n}\nasync function $fd9aaa441bfc2baf$export$bdf0422c029b202a(resourceUrl, contentType, options) {\n    const cacheKey = $fd9aaa441bfc2baf$var$getCacheKey(resourceUrl, contentType, options.includeQueryParams);\n    if ($fd9aaa441bfc2baf$var$cache[cacheKey] != null) return $fd9aaa441bfc2baf$var$cache[cacheKey];\n    // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n    if (options.cacheBust) // eslint-disable-next-line no-param-reassign\n    resourceUrl += (/\\?/.test(resourceUrl) ? \"&\" : \"?\") + new Date().getTime();\n    let dataURL;\n    try {\n        const content = await $fd9aaa441bfc2baf$export$c20a8b76c95b0d41(resourceUrl, options.fetchRequestInit, ({ res: res, result: result })=>{\n            if (!contentType) // eslint-disable-next-line no-param-reassign\n            contentType = res.headers.get(\"Content-Type\") || \"\";\n            return $fd9aaa441bfc2baf$var$getContentFromDataUrl(result);\n        });\n        dataURL = $fd9aaa441bfc2baf$export$68336ea1617fa80a(content, contentType);\n    } catch (error) {\n        dataURL = options.imagePlaceholder || \"\";\n        let msg = `Failed to fetch resource: ${resourceUrl}`;\n        if (error) msg = typeof error === \"string\" ? error : error.message;\n        if (msg) console.warn(msg);\n    }\n    $fd9aaa441bfc2baf$var$cache[cacheKey] = dataURL;\n    return dataURL;\n}\n\n\nasync function $dc746d806551912c$var$cloneCanvasElement(canvas) {\n    const dataURL = canvas.toDataURL();\n    if (dataURL === \"data:,\") return canvas.cloneNode(false);\n    return (0, $9eb70742a7095e98$export$ec664d7487540b)(dataURL);\n}\nasync function $dc746d806551912c$var$cloneVideoElement(video, options) {\n    if (video.currentSrc) {\n        const canvas = document.createElement(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n        canvas.width = video.clientWidth;\n        canvas.height = video.clientHeight;\n        ctx === null || ctx === void 0 || ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n        const dataURL = canvas.toDataURL();\n        return (0, $9eb70742a7095e98$export$ec664d7487540b)(dataURL);\n    }\n    const poster = video.poster;\n    const contentType = (0, $67e830aaea99e7b5$export$200548c990602f61)(poster);\n    const dataURL = await (0, $fd9aaa441bfc2baf$export$bdf0422c029b202a)(poster, contentType, options);\n    return (0, $9eb70742a7095e98$export$ec664d7487540b)(dataURL);\n}\nasync function $dc746d806551912c$var$cloneIFrameElement(iframe) {\n    var _a;\n    try {\n        if ((_a = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.body) return await $dc746d806551912c$export$ae8e35ea29ddac22(iframe.contentDocument.body, {}, true);\n    } catch (_b) {\n    // Failed to clone iframe\n    }\n    return iframe.cloneNode(false);\n}\nasync function $dc746d806551912c$var$cloneSingleNode(node, options) {\n    if ((0, $9eb70742a7095e98$export$3a92fc9ec83ef360)(node, HTMLCanvasElement)) return $dc746d806551912c$var$cloneCanvasElement(node);\n    if ((0, $9eb70742a7095e98$export$3a92fc9ec83ef360)(node, HTMLVideoElement)) return $dc746d806551912c$var$cloneVideoElement(node, options);\n    if ((0, $9eb70742a7095e98$export$3a92fc9ec83ef360)(node, HTMLIFrameElement)) return $dc746d806551912c$var$cloneIFrameElement(node);\n    return node.cloneNode(false);\n}\nconst $dc746d806551912c$var$isSlotElement = (node)=>node.tagName != null && node.tagName.toUpperCase() === \"SLOT\";\nasync function $dc746d806551912c$var$cloneChildren(nativeNode, clonedNode, options) {\n    var _a, _b;\n    let children = [];\n    if ($dc746d806551912c$var$isSlotElement(nativeNode) && nativeNode.assignedNodes) children = (0, $9eb70742a7095e98$export$45b10814cc054894)(nativeNode.assignedNodes());\n    else if ((0, $9eb70742a7095e98$export$3a92fc9ec83ef360)(nativeNode, HTMLIFrameElement) && ((_a = nativeNode.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) children = (0, $9eb70742a7095e98$export$45b10814cc054894)(nativeNode.contentDocument.body.childNodes);\n    else children = (0, $9eb70742a7095e98$export$45b10814cc054894)(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes);\n    if (children.length === 0 || (0, $9eb70742a7095e98$export$3a92fc9ec83ef360)(nativeNode, HTMLVideoElement)) return clonedNode;\n    await children.reduce((deferred, child)=>deferred.then(()=>$dc746d806551912c$export$ae8e35ea29ddac22(child, options)).then((clonedChild)=>{\n            if (clonedChild) clonedNode.appendChild(clonedChild);\n        }), Promise.resolve());\n    return clonedNode;\n}\nfunction $dc746d806551912c$var$cloneCSSStyle(nativeNode, clonedNode) {\n    const targetStyle = clonedNode.style;\n    if (!targetStyle) return;\n    const sourceStyle = window.getComputedStyle(nativeNode);\n    if (sourceStyle.cssText) {\n        targetStyle.cssText = sourceStyle.cssText;\n        targetStyle.transformOrigin = sourceStyle.transformOrigin;\n    } else (0, $9eb70742a7095e98$export$45b10814cc054894)(sourceStyle).forEach((name)=>{\n        let value = sourceStyle.getPropertyValue(name);\n        if (name === \"font-size\" && value.endsWith(\"px\")) {\n            const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;\n            value = `${reducedFont}px`;\n        }\n        if ((0, $9eb70742a7095e98$export$3a92fc9ec83ef360)(nativeNode, HTMLIFrameElement) && name === \"display\" && value === \"inline\") value = \"block\";\n        if (name === \"d\" && clonedNode.getAttribute(\"d\")) value = `path(${clonedNode.getAttribute(\"d\")})`;\n        targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));\n    });\n}\nfunction $dc746d806551912c$var$cloneInputValue(nativeNode, clonedNode) {\n    if ((0, $9eb70742a7095e98$export$3a92fc9ec83ef360)(nativeNode, HTMLTextAreaElement)) clonedNode.innerHTML = nativeNode.value;\n    if ((0, $9eb70742a7095e98$export$3a92fc9ec83ef360)(nativeNode, HTMLInputElement)) clonedNode.setAttribute(\"value\", nativeNode.value);\n}\nfunction $dc746d806551912c$var$cloneSelectValue(nativeNode, clonedNode) {\n    if ((0, $9eb70742a7095e98$export$3a92fc9ec83ef360)(nativeNode, HTMLSelectElement)) {\n        const clonedSelect = clonedNode;\n        const selectedOption = Array.from(clonedSelect.children).find((child)=>nativeNode.value === child.getAttribute(\"value\"));\n        if (selectedOption) selectedOption.setAttribute(\"selected\", \"\");\n    }\n}\nfunction $dc746d806551912c$var$decorate(nativeNode, clonedNode) {\n    if ((0, $9eb70742a7095e98$export$3a92fc9ec83ef360)(clonedNode, Element)) {\n        $dc746d806551912c$var$cloneCSSStyle(nativeNode, clonedNode);\n        (0, $f1d3d4da19ace37e$export$8df63687a708ed2e)(nativeNode, clonedNode);\n        $dc746d806551912c$var$cloneInputValue(nativeNode, clonedNode);\n        $dc746d806551912c$var$cloneSelectValue(nativeNode, clonedNode);\n    }\n    return clonedNode;\n}\nasync function $dc746d806551912c$var$ensureSVGSymbols(clone, options) {\n    const uses = clone.querySelectorAll ? clone.querySelectorAll(\"use\") : [];\n    if (uses.length === 0) return clone;\n    const processedDefs = {};\n    for(let i = 0; i < uses.length; i++){\n        const use = uses[i];\n        const id = use.getAttribute(\"xlink:href\");\n        if (id) {\n            const exist = clone.querySelector(id);\n            const definition = document.querySelector(id);\n            if (!exist && definition && !processedDefs[id]) // eslint-disable-next-line no-await-in-loop\n            processedDefs[id] = await $dc746d806551912c$export$ae8e35ea29ddac22(definition, options, true);\n        }\n    }\n    const nodes = Object.values(processedDefs);\n    if (nodes.length) {\n        const ns = \"http://www.w3.org/1999/xhtml\";\n        const svg = document.createElementNS(ns, \"svg\");\n        svg.setAttribute(\"xmlns\", ns);\n        svg.style.position = \"absolute\";\n        svg.style.width = \"0\";\n        svg.style.height = \"0\";\n        svg.style.overflow = \"hidden\";\n        svg.style.display = \"none\";\n        const defs = document.createElementNS(ns, \"defs\");\n        svg.appendChild(defs);\n        for(let i = 0; i < nodes.length; i++)defs.appendChild(nodes[i]);\n        clone.appendChild(svg);\n    }\n    return clone;\n}\nasync function $dc746d806551912c$export$ae8e35ea29ddac22(node, options, isRoot) {\n    if (!isRoot && options.filter && !options.filter(node)) return null;\n    return Promise.resolve(node).then((clonedNode)=>$dc746d806551912c$var$cloneSingleNode(clonedNode, options)).then((clonedNode)=>$dc746d806551912c$var$cloneChildren(node, clonedNode, options)).then((clonedNode)=>$dc746d806551912c$var$decorate(node, clonedNode)).then((clonedNode)=>$dc746d806551912c$var$ensureSVGSymbols(clonedNode, options));\n}\n\n\n\n\n\nconst $8cc1ee3e9af11276$var$URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nconst $8cc1ee3e9af11276$var$URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"']?)([^\"']+)\\1\\)/g;\nconst $8cc1ee3e9af11276$var$FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nfunction $8cc1ee3e9af11276$var$toRegex(url) {\n    // eslint-disable-next-line no-useless-escape\n    const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\n    return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, \"g\");\n}\nfunction $8cc1ee3e9af11276$export$d04549d631b8762d(cssText) {\n    const urls = [];\n    cssText.replace($8cc1ee3e9af11276$var$URL_REGEX, (raw, quotation, url)=>{\n        urls.push(url);\n        return raw;\n    });\n    return urls.filter((url)=>!(0, $fd9aaa441bfc2baf$export$f8a05efa20ffd5a)(url));\n}\nasync function $8cc1ee3e9af11276$export$2be46bb7e96db87f(cssText, resourceURL, baseURL, options, getContentFromUrl) {\n    try {\n        const resolvedURL = baseURL ? (0, $9eb70742a7095e98$export$f85c16a6d62f7d63)(resourceURL, baseURL) : resourceURL;\n        const contentType = (0, $67e830aaea99e7b5$export$200548c990602f61)(resourceURL);\n        let dataURL;\n        if (getContentFromUrl) {\n            const content = await getContentFromUrl(resolvedURL);\n            dataURL = (0, $fd9aaa441bfc2baf$export$68336ea1617fa80a)(content, contentType);\n        } else dataURL = await (0, $fd9aaa441bfc2baf$export$bdf0422c029b202a)(resolvedURL, contentType, options);\n        return cssText.replace($8cc1ee3e9af11276$var$toRegex(resourceURL), `$1${dataURL}$3`);\n    } catch (error) {\n    // pass\n    }\n    return cssText;\n}\nfunction $8cc1ee3e9af11276$var$filterPreferredFontFormat(str, { preferredFontFormat: preferredFontFormat }) {\n    return !preferredFontFormat ? str : str.replace($8cc1ee3e9af11276$var$FONT_SRC_REGEX, (match)=>{\n        // eslint-disable-next-line no-constant-condition\n        while(true){\n            const [src, , format] = $8cc1ee3e9af11276$var$URL_WITH_FORMAT_REGEX.exec(match) || [];\n            if (!format) return \"\";\n            if (format === preferredFontFormat) return `src: ${src};`;\n        }\n    });\n}\nfunction $8cc1ee3e9af11276$export$7b668369e5eab853(url) {\n    return url.search($8cc1ee3e9af11276$var$URL_REGEX) !== -1;\n}\nasync function $8cc1ee3e9af11276$export$3d88803585cbbc21(cssText, baseUrl, options) {\n    if (!$8cc1ee3e9af11276$export$7b668369e5eab853(cssText)) return cssText;\n    const filteredCSSText = $8cc1ee3e9af11276$var$filterPreferredFontFormat(cssText, options);\n    const urls = $8cc1ee3e9af11276$export$d04549d631b8762d(filteredCSSText);\n    return urls.reduce((deferred, url)=>deferred.then((css)=>$8cc1ee3e9af11276$export$2be46bb7e96db87f(css, url, baseUrl, options)), Promise.resolve(filteredCSSText));\n}\n\n\n\n\n\nasync function $5938d0f1526f12ac$var$embedProp(propName, node, options) {\n    var _a;\n    const propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);\n    if (propValue) {\n        const cssString = await (0, $8cc1ee3e9af11276$export$3d88803585cbbc21)(propValue, null, options);\n        node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));\n        return true;\n    }\n    return false;\n}\nasync function $5938d0f1526f12ac$var$embedBackground(clonedNode, options) {\n    if (!await $5938d0f1526f12ac$var$embedProp(\"background\", clonedNode, options)) await $5938d0f1526f12ac$var$embedProp(\"background-image\", clonedNode, options);\n    if (!await $5938d0f1526f12ac$var$embedProp(\"mask\", clonedNode, options)) await $5938d0f1526f12ac$var$embedProp(\"mask-image\", clonedNode, options);\n}\nasync function $5938d0f1526f12ac$var$embedImageNode(clonedNode, options) {\n    const isImageElement = (0, $9eb70742a7095e98$export$3a92fc9ec83ef360)(clonedNode, HTMLImageElement);\n    if (!(isImageElement && !(0, $fd9aaa441bfc2baf$export$f8a05efa20ffd5a)(clonedNode.src)) && !((0, $9eb70742a7095e98$export$3a92fc9ec83ef360)(clonedNode, SVGImageElement) && !(0, $fd9aaa441bfc2baf$export$f8a05efa20ffd5a)(clonedNode.href.baseVal))) return;\n    const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;\n    const dataURL = await (0, $fd9aaa441bfc2baf$export$bdf0422c029b202a)(url, (0, $67e830aaea99e7b5$export$200548c990602f61)(url), options);\n    await new Promise((resolve, reject)=>{\n        clonedNode.onload = resolve;\n        clonedNode.onerror = reject;\n        const image = clonedNode;\n        if (image.decode) image.decode = resolve;\n        if (image.loading === \"lazy\") image.loading = \"eager\";\n        if (isImageElement) {\n            clonedNode.srcset = \"\";\n            clonedNode.src = dataURL;\n        } else clonedNode.href.baseVal = dataURL;\n    });\n}\nasync function $5938d0f1526f12ac$var$embedChildren(clonedNode, options) {\n    const children = (0, $9eb70742a7095e98$export$45b10814cc054894)(clonedNode.childNodes);\n    const deferreds = children.map((child)=>$5938d0f1526f12ac$export$6660fa8dd20e53aa(child, options));\n    await Promise.all(deferreds).then(()=>clonedNode);\n}\nasync function $5938d0f1526f12ac$export$6660fa8dd20e53aa(clonedNode, options) {\n    if ((0, $9eb70742a7095e98$export$3a92fc9ec83ef360)(clonedNode, Element)) {\n        await $5938d0f1526f12ac$var$embedBackground(clonedNode, options);\n        await $5938d0f1526f12ac$var$embedImageNode(clonedNode, options);\n        await $5938d0f1526f12ac$var$embedChildren(clonedNode, options);\n    }\n}\n\n\nfunction $07c931b022560f33$export$d63a6b7859608045(node, options) {\n    const { style: style } = node;\n    if (options.backgroundColor) style.backgroundColor = options.backgroundColor;\n    if (options.width) style.width = `${options.width}px`;\n    if (options.height) style.height = `${options.height}px`;\n    const manual = options.style;\n    if (manual != null) Object.keys(manual).forEach((key)=>{\n        style[key] = manual[key];\n    });\n    return node;\n}\n\n\n\n\n\nconst $673cafb05cbd0034$var$cssFetchCache = {};\nasync function $673cafb05cbd0034$var$fetchCSS(url) {\n    let cache = $673cafb05cbd0034$var$cssFetchCache[url];\n    if (cache != null) return cache;\n    const res = await fetch(url);\n    const cssText = await res.text();\n    cache = {\n        url: url,\n        cssText: cssText\n    };\n    $673cafb05cbd0034$var$cssFetchCache[url] = cache;\n    return cache;\n}\nasync function $673cafb05cbd0034$var$embedFonts(data, options) {\n    let cssText = data.cssText;\n    const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g;\n    const fontLocs = cssText.match(/url\\([^)]+\\)/g) || [];\n    const loadFonts = fontLocs.map(async (loc)=>{\n        let url = loc.replace(regexUrl, \"$1\");\n        if (!url.startsWith(\"https://\")) url = new URL(url, data.url).href;\n        return (0, $fd9aaa441bfc2baf$export$c20a8b76c95b0d41)(url, options.fetchRequestInit, ({ result: result })=>{\n            cssText = cssText.replace(loc, `url(${result})`);\n            return [\n                loc,\n                result\n            ];\n        });\n    });\n    return Promise.all(loadFonts).then(()=>cssText);\n}\nfunction $673cafb05cbd0034$var$parseCSS(source) {\n    if (source == null) return [];\n    const result = [];\n    const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi;\n    // strip out comments\n    let cssText = source.replace(commentsRegex, \"\");\n    // eslint-disable-next-line prefer-regex-literals\n    const keyframesRegex = new RegExp(\"((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})\", \"gi\");\n    // eslint-disable-next-line no-constant-condition\n    while(true){\n        const matches = keyframesRegex.exec(cssText);\n        if (matches === null) break;\n        result.push(matches[0]);\n    }\n    cssText = cssText.replace(keyframesRegex, \"\");\n    const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi;\n    // to match css & media queries together\n    const combinedCSSRegex = \"((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})\";\n    // unified regex\n    const unifiedRegex = new RegExp(combinedCSSRegex, \"gi\");\n    // eslint-disable-next-line no-constant-condition\n    while(true){\n        let matches = importRegex.exec(cssText);\n        if (matches === null) {\n            matches = unifiedRegex.exec(cssText);\n            if (matches === null) break;\n            else importRegex.lastIndex = unifiedRegex.lastIndex;\n        } else unifiedRegex.lastIndex = importRegex.lastIndex;\n        result.push(matches[0]);\n    }\n    return result;\n}\nasync function $673cafb05cbd0034$var$getCSSRules(styleSheets, options) {\n    const ret = [];\n    const deferreds = [];\n    // First loop inlines imports\n    styleSheets.forEach((sheet)=>{\n        if (\"cssRules\" in sheet) try {\n            (0, $9eb70742a7095e98$export$45b10814cc054894)(sheet.cssRules || []).forEach((item, index)=>{\n                if (item.type === CSSRule.IMPORT_RULE) {\n                    let importIndex = index + 1;\n                    const url = item.href;\n                    const deferred = $673cafb05cbd0034$var$fetchCSS(url).then((metadata)=>$673cafb05cbd0034$var$embedFonts(metadata, options)).then((cssText)=>$673cafb05cbd0034$var$parseCSS(cssText).forEach((rule)=>{\n                            try {\n                                sheet.insertRule(rule, rule.startsWith(\"@import\") ? importIndex += 1 : sheet.cssRules.length);\n                            } catch (error) {\n                                console.error(\"Error inserting rule from remote css\", {\n                                    rule: rule,\n                                    error: error\n                                });\n                            }\n                        })).catch((e)=>{\n                        console.error(\"Error loading remote css\", e.toString());\n                    });\n                    deferreds.push(deferred);\n                }\n            });\n        } catch (e) {\n            const inline = styleSheets.find((a)=>a.href == null) || document.styleSheets[0];\n            if (sheet.href != null) deferreds.push($673cafb05cbd0034$var$fetchCSS(sheet.href).then((metadata)=>$673cafb05cbd0034$var$embedFonts(metadata, options)).then((cssText)=>$673cafb05cbd0034$var$parseCSS(cssText).forEach((rule)=>{\n                    inline.insertRule(rule, sheet.cssRules.length);\n                })).catch((err)=>{\n                console.error(\"Error loading remote stylesheet\", err);\n            }));\n            console.error(\"Error inlining remote css file\", e);\n        }\n    });\n    return Promise.all(deferreds).then(()=>{\n        // Second loop parses rules\n        styleSheets.forEach((sheet)=>{\n            if (\"cssRules\" in sheet) try {\n                (0, $9eb70742a7095e98$export$45b10814cc054894)(sheet.cssRules || []).forEach((item)=>{\n                    ret.push(item);\n                });\n            } catch (e) {\n                console.error(`Error while reading CSS rules from ${sheet.href}`, e);\n            }\n        });\n        return ret;\n    });\n}\nfunction $673cafb05cbd0034$var$getWebFontRules(cssRules) {\n    return cssRules.filter((rule)=>rule.type === CSSRule.FONT_FACE_RULE).filter((rule)=>(0, $8cc1ee3e9af11276$export$7b668369e5eab853)(rule.style.getPropertyValue(\"src\")));\n}\nasync function $673cafb05cbd0034$var$parseWebFontRules(node, options) {\n    if (node.ownerDocument == null) throw new Error(\"Provided element is not within a Document\");\n    const styleSheets = (0, $9eb70742a7095e98$export$45b10814cc054894)(node.ownerDocument.styleSheets);\n    const cssRules = await $673cafb05cbd0034$var$getCSSRules(styleSheets, options);\n    return $673cafb05cbd0034$var$getWebFontRules(cssRules);\n}\nasync function $673cafb05cbd0034$export$253c9aa3d83a57b6(node, options) {\n    const rules = await $673cafb05cbd0034$var$parseWebFontRules(node, options);\n    const cssTexts = await Promise.all(rules.map((rule)=>{\n        const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;\n        return (0, $8cc1ee3e9af11276$export$3d88803585cbbc21)(rule.cssText, baseUrl, options);\n    }));\n    return cssTexts.join(\"\\n\");\n}\nasync function $673cafb05cbd0034$export$2c2c83b77c8cb421(clonedNode, options) {\n    const cssText = options.fontEmbedCSS != null ? options.fontEmbedCSS : options.skipFonts ? null : await $673cafb05cbd0034$export$253c9aa3d83a57b6(clonedNode, options);\n    if (cssText) {\n        const styleNode = document.createElement(\"style\");\n        const sytleContent = document.createTextNode(cssText);\n        styleNode.appendChild(sytleContent);\n        if (clonedNode.firstChild) clonedNode.insertBefore(styleNode, clonedNode.firstChild);\n        else clonedNode.appendChild(styleNode);\n    }\n}\n\n\n\nasync function $8fb130f5e2a07b68$export$20d300cb2d558b7(node, options = {}) {\n    const { width: width, height: height } = (0, $9eb70742a7095e98$export$ada5537b2c061996)(node, options);\n    const clonedNode = await (0, $dc746d806551912c$export$ae8e35ea29ddac22)(node, options, true);\n    await (0, $673cafb05cbd0034$export$2c2c83b77c8cb421)(clonedNode, options);\n    await (0, $5938d0f1526f12ac$export$6660fa8dd20e53aa)(clonedNode, options);\n    (0, $07c931b022560f33$export$d63a6b7859608045)(clonedNode, options);\n    const datauri = await (0, $9eb70742a7095e98$export$b62810fb8ca515fa)(clonedNode, width, height);\n    return datauri;\n}\nasync function $8fb130f5e2a07b68$export$f87f6982d1fd4f81(node, options = {}) {\n    const { width: width, height: height } = (0, $9eb70742a7095e98$export$ada5537b2c061996)(node, options);\n    const svg = await $8fb130f5e2a07b68$export$20d300cb2d558b7(node, options);\n    const img = await (0, $9eb70742a7095e98$export$ec664d7487540b)(svg);\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext(\"2d\");\n    const ratio = options.pixelRatio || (0, $9eb70742a7095e98$export$d39ce20a37bba061)();\n    const canvasWidth = options.canvasWidth || width;\n    const canvasHeight = options.canvasHeight || height;\n    canvas.width = canvasWidth * ratio;\n    canvas.height = canvasHeight * ratio;\n    if (!options.skipAutoScale) (0, $9eb70742a7095e98$export$c2c809a2fe6b0f1a)(canvas);\n    canvas.style.width = `${canvasWidth}`;\n    canvas.style.height = `${canvasHeight}`;\n    if (options.backgroundColor) {\n        context.fillStyle = options.backgroundColor;\n        context.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    context.drawImage(img, 0, 0, canvas.width, canvas.height);\n    return canvas;\n}\nasync function $8fb130f5e2a07b68$export$6f9e32581c0cde11(node, options = {}) {\n    const { width: width, height: height } = (0, $9eb70742a7095e98$export$ada5537b2c061996)(node, options);\n    const canvas = await $8fb130f5e2a07b68$export$f87f6982d1fd4f81(node, options);\n    const ctx = canvas.getContext(\"2d\");\n    return ctx.getImageData(0, 0, width, height).data;\n}\nasync function $8fb130f5e2a07b68$export$aba256f33615c92e(node, options = {}) {\n    const canvas = await $8fb130f5e2a07b68$export$f87f6982d1fd4f81(node, options);\n    return canvas.toDataURL();\n}\nasync function $8fb130f5e2a07b68$export$ed218bd2440d33a5(node, options = {}) {\n    const canvas = await $8fb130f5e2a07b68$export$f87f6982d1fd4f81(node, options);\n    return canvas.toDataURL(\"image/jpeg\", options.quality || 1);\n}\nasync function $8fb130f5e2a07b68$export$b20f4ee19ffa0668(node, options = {}) {\n    const canvas = await $8fb130f5e2a07b68$export$f87f6982d1fd4f81(node, options);\n    const blob = await (0, $9eb70742a7095e98$export$403d539f215df596)(canvas);\n    return blob;\n}\nasync function $8fb130f5e2a07b68$export$92678bad7eef403b(node, options = {}) {\n    return (0, $673cafb05cbd0034$export$253c9aa3d83a57b6)(node, options);\n}\n\n\nvar $90f256c567e4c320$exports = {};\n(function(a, b) {\n    if (\"function\" == typeof define && define.amd) define([], b);\n    else b();\n})($90f256c567e4c320$exports, function() {\n    \"use strict\";\n    function b(a, b) {\n        return \"undefined\" == typeof b ? b = {\n            autoBom: !1\n        } : \"object\" != typeof b && (console.warn(\"Deprecated: Expected third argument to be a object\"), b = {\n            autoBom: !b\n        }), b.autoBom && /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(a.type) ? new Blob([\n            \"\\uFEFF\",\n            a\n        ], {\n            type: a.type\n        }) : a;\n    }\n    function c(a, b, c) {\n        var d = new XMLHttpRequest;\n        d.open(\"GET\", a), d.responseType = \"blob\", d.onload = function() {\n            g(d.response, b, c);\n        }, d.onerror = function() {\n            console.error(\"could not download file\");\n        }, d.send();\n    }\n    function d(a) {\n        var b = new XMLHttpRequest;\n        b.open(\"HEAD\", a, !1);\n        try {\n            b.send();\n        } catch (a) {}\n        return 200 <= b.status && 299 >= b.status;\n    }\n    function e(a) {\n        try {\n            a.dispatchEvent(new MouseEvent(\"click\"));\n        } catch (c) {\n            var b = document.createEvent(\"MouseEvents\");\n            b.initMouseEvent(\"click\", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), a.dispatchEvent(b);\n        }\n    }\n    var f = \"object\" == typeof window && window.window === window ? window : \"object\" == typeof self && self.self === self ? self : \"object\" == typeof $parcel$global && $parcel$global.global === $parcel$global ? $parcel$global : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || (\"object\" != typeof window || window !== f ? function() {} : \"download\" in HTMLAnchorElement.prototype && !a ? function(b, g, h) {\n        var i = f.URL || f.webkitURL, j = document.createElement(\"a\");\n        g = g || b.name || \"download\", j.download = g, j.rel = \"noopener\", \"string\" == typeof b ? (j.href = b, j.origin === location.origin ? e(j) : d(j.href) ? c(b, g, h) : e(j, j.target = \"_blank\")) : (j.href = i.createObjectURL(b), setTimeout(function() {\n            i.revokeObjectURL(j.href);\n        }, 4E4), setTimeout(function() {\n            e(j);\n        }, 0));\n    } : \"msSaveOrOpenBlob\" in navigator ? function(f, g, h) {\n        if (g = g || f.name || \"download\", \"string\" != typeof f) navigator.msSaveOrOpenBlob(b(f, h), g);\n        else if (d(f)) c(f, g, h);\n        else {\n            var i = document.createElement(\"a\");\n            i.href = f, i.target = \"_blank\", setTimeout(function() {\n                e(i);\n            });\n        }\n    } : function(b, d, e, g) {\n        if (g = g || open(\"\", \"_blank\"), g && (g.document.title = g.document.body.innerText = \"downloading...\"), \"string\" == typeof b) return c(b, d, e);\n        var h = \"application/octet-stream\" === b.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\\/[\\d]+/.test(navigator.userAgent);\n        if ((j || h && i || a) && \"undefined\" != typeof FileReader) {\n            var k = new FileReader;\n            k.onloadend = function() {\n                var a = k.result;\n                a = j ? a : a.replace(/^data:[^;]*;/, \"data:attachment/file;\"), g ? g.location.href = a : location = a, g = null;\n            }, k.readAsDataURL(b);\n        } else {\n            var l = f.URL || f.webkitURL, m = l.createObjectURL(b);\n            g ? g.location = m : location.href = m, g = null, setTimeout(function() {\n                l.revokeObjectURL(m);\n            }, 4E4);\n        }\n    });\n    f.saveAs = g.saveAs = g, $90f256c567e4c320$exports = g;\n});\n\n\nwindow.onload = ()=>{\n    const buttonEl = document.getElementsByTagName(\"button\")[0];\n    const textareaEl = document.getElementsByTagName(\"textarea\")[0];\n    const outputSection = document.getElementsByTagName(\"section\")[0];\n    const outputTextEl = document.getElementById(\"output_meme_text\");\n    // Click button and create meme\n    buttonEl.addEventListener(\"click\", ()=>{\n        const memeText = makeAlternatingCase(textareaEl.value);\n        outputSection.style.display = \"block\";\n        outputTextEl.textContent = memeText;\n        // Convert HTML to image and download\n        const res = convertElementToImage(outputSection);\n        console.log(res);\n        (0, $90f256c567e4c320$exports.saveAs)(convertElementToImage(outputSection), \"mocking-spongebob-meme.png\");\n    });\n    // Make meme text\n    function makeAlternatingCase(text) {\n        let alternateCaseText = \"\";\n        for(let i = 0; i < text.length; i++)if (i % 2 === 0) alternateCaseText += text[i].toLowerCase();\n        else alternateCaseText += text[i].toUpperCase();\n        return alternateCaseText;\n    }\n    // Convert element to image\n    async function convertElementToImage(element) {\n        let imageData;\n        return await (0, $8fb130f5e2a07b68$export$aba256f33615c92e)(element).then(function(dataUrl) {\n            return dataUrl;\n        });\n    }\n};\n\n\n//# sourceMappingURL=index.ce9b5ce0.js.map\n","import { toPng } from \"html-to-image\";\nimport { saveAs } from \"file-saver\";\n\nwindow.onload = () => {\n  const buttonEl = document.getElementsByTagName(\"button\")[0];\n  const textareaEl = document.getElementsByTagName(\"textarea\")[0];\n  const outputSection = document.getElementsByTagName(\"section\")[0];\n  const outputTextEl = document.getElementById(\"output_meme_text\");\n\n  // Click button and create meme\n  buttonEl.addEventListener(\"click\", () => {\n    const memeText = makeAlternatingCase(textareaEl.value);\n\n    outputSection.style.display = \"block\";\n    outputTextEl.textContent = memeText;\n\n    // Convert HTML to image and download\n    const res = convertElementToImage(outputSection);\n    console.log(res);\n    saveAs(convertElementToImage(outputSection), \"mocking-spongebob-meme.png\");\n  });\n\n  // Make meme text\n  function makeAlternatingCase(text) {\n    let alternateCaseText = \"\";\n\n    for (let i = 0; i < text.length; i++) {\n      if (i % 2 === 0) {\n        alternateCaseText += text[i].toLowerCase();\n      } else {\n        alternateCaseText += text[i].toUpperCase();\n      }\n    }\n\n    return alternateCaseText;\n  }\n\n  // Convert element to image\n  async function convertElementToImage(element) {\n    let imageData;\n\n    return await toPng(element).then(function (dataUrl) {\n      return dataUrl;\n    });\n\n    return imageData;\n  }\n};\n","import { cloneNode } from './clone-node';\nimport { embedImages } from './embed-images';\nimport { applyStyle } from './apply-style';\nimport { embedWebFonts, getWebFontCSS } from './embed-webfonts';\nimport { getImageSize, getPixelRatio, createImage, canvasToBlob, nodeToDataURL, checkCanvasDimensions, } from './util';\nexport async function toSvg(node, options = {}) {\n    const { width, height } = getImageSize(node, options);\n    const clonedNode = (await cloneNode(node, options, true));\n    await embedWebFonts(clonedNode, options);\n    await embedImages(clonedNode, options);\n    applyStyle(clonedNode, options);\n    const datauri = await nodeToDataURL(clonedNode, width, height);\n    return datauri;\n}\nexport async function toCanvas(node, options = {}) {\n    const { width, height } = getImageSize(node, options);\n    const svg = await toSvg(node, options);\n    const img = await createImage(svg);\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    const ratio = options.pixelRatio || getPixelRatio();\n    const canvasWidth = options.canvasWidth || width;\n    const canvasHeight = options.canvasHeight || height;\n    canvas.width = canvasWidth * ratio;\n    canvas.height = canvasHeight * ratio;\n    if (!options.skipAutoScale) {\n        checkCanvasDimensions(canvas);\n    }\n    canvas.style.width = `${canvasWidth}`;\n    canvas.style.height = `${canvasHeight}`;\n    if (options.backgroundColor) {\n        context.fillStyle = options.backgroundColor;\n        context.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    context.drawImage(img, 0, 0, canvas.width, canvas.height);\n    return canvas;\n}\nexport async function toPixelData(node, options = {}) {\n    const { width, height } = getImageSize(node, options);\n    const canvas = await toCanvas(node, options);\n    const ctx = canvas.getContext('2d');\n    return ctx.getImageData(0, 0, width, height).data;\n}\nexport async function toPng(node, options = {}) {\n    const canvas = await toCanvas(node, options);\n    return canvas.toDataURL();\n}\nexport async function toJpeg(node, options = {}) {\n    const canvas = await toCanvas(node, options);\n    return canvas.toDataURL('image/jpeg', options.quality || 1);\n}\nexport async function toBlob(node, options = {}) {\n    const canvas = await toCanvas(node, options);\n    const blob = await canvasToBlob(canvas);\n    return blob;\n}\nexport async function getFontEmbedCSS(node, options = {}) {\n    return getWebFontCSS(node, options);\n}\n//# sourceMappingURL=index.js.map","import { Options } from './types'\nimport { cloneNode } from './clone-node'\nimport { embedImages } from './embed-images'\nimport { applyStyle } from './apply-style'\nimport { embedWebFonts, getWebFontCSS } from './embed-webfonts'\nimport {\n  getImageSize,\n  getPixelRatio,\n  createImage,\n  canvasToBlob,\n  nodeToDataURL,\n  checkCanvasDimensions,\n} from './util'\n\nexport async function toSvg<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  const { width, height } = getImageSize(node, options)\n  const clonedNode = (await cloneNode(node, options, true)) as HTMLElement\n  await embedWebFonts(clonedNode, options)\n  await embedImages(clonedNode, options)\n  applyStyle(clonedNode, options)\n  const datauri = await nodeToDataURL(clonedNode, width, height)\n  return datauri\n}\n\nexport async function toCanvas<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<HTMLCanvasElement> {\n  const { width, height } = getImageSize(node, options)\n  const svg = await toSvg(node, options)\n  const img = await createImage(svg)\n\n  const canvas = document.createElement('canvas')\n  const context = canvas.getContext('2d')!\n  const ratio = options.pixelRatio || getPixelRatio()\n  const canvasWidth = options.canvasWidth || width\n  const canvasHeight = options.canvasHeight || height\n\n  canvas.width = canvasWidth * ratio\n  canvas.height = canvasHeight * ratio\n\n  if (!options.skipAutoScale) {\n    checkCanvasDimensions(canvas)\n  }\n  canvas.style.width = `${canvasWidth}`\n  canvas.style.height = `${canvasHeight}`\n\n  if (options.backgroundColor) {\n    context.fillStyle = options.backgroundColor\n    context.fillRect(0, 0, canvas.width, canvas.height)\n  }\n\n  context.drawImage(img, 0, 0, canvas.width, canvas.height)\n\n  return canvas\n}\n\nexport async function toPixelData<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<Uint8ClampedArray> {\n  const { width, height } = getImageSize(node, options)\n  const canvas = await toCanvas(node, options)\n  const ctx = canvas.getContext('2d')!\n  return ctx.getImageData(0, 0, width, height).data\n}\n\nexport async function toPng<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  const canvas = await toCanvas(node, options)\n  return canvas.toDataURL()\n}\n\nexport async function toJpeg<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  const canvas = await toCanvas(node, options)\n  return canvas.toDataURL('image/jpeg', options.quality || 1)\n}\n\nexport async function toBlob<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<Blob | null> {\n  const canvas = await toCanvas(node, options)\n  const blob = await canvasToBlob(canvas)\n  return blob\n}\n\nexport async function getFontEmbedCSS<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  return getWebFontCSS(node, options)\n}\n","import { clonePseudoElements } from './clone-pseudos';\nimport { createImage, toArray, isInstanceOfElement } from './util';\nimport { getMimeType } from './mimes';\nimport { resourceToDataURL } from './dataurl';\nasync function cloneCanvasElement(canvas) {\n    const dataURL = canvas.toDataURL();\n    if (dataURL === 'data:,') {\n        return canvas.cloneNode(false);\n    }\n    return createImage(dataURL);\n}\nasync function cloneVideoElement(video, options) {\n    if (video.currentSrc) {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        canvas.width = video.clientWidth;\n        canvas.height = video.clientHeight;\n        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n        const dataURL = canvas.toDataURL();\n        return createImage(dataURL);\n    }\n    const poster = video.poster;\n    const contentType = getMimeType(poster);\n    const dataURL = await resourceToDataURL(poster, contentType, options);\n    return createImage(dataURL);\n}\nasync function cloneIFrameElement(iframe) {\n    var _a;\n    try {\n        if ((_a = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.body) {\n            return (await cloneNode(iframe.contentDocument.body, {}, true));\n        }\n    }\n    catch (_b) {\n        // Failed to clone iframe\n    }\n    return iframe.cloneNode(false);\n}\nasync function cloneSingleNode(node, options) {\n    if (isInstanceOfElement(node, HTMLCanvasElement)) {\n        return cloneCanvasElement(node);\n    }\n    if (isInstanceOfElement(node, HTMLVideoElement)) {\n        return cloneVideoElement(node, options);\n    }\n    if (isInstanceOfElement(node, HTMLIFrameElement)) {\n        return cloneIFrameElement(node);\n    }\n    return node.cloneNode(false);\n}\nconst isSlotElement = (node) => node.tagName != null && node.tagName.toUpperCase() === 'SLOT';\nasync function cloneChildren(nativeNode, clonedNode, options) {\n    var _a, _b;\n    let children = [];\n    if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {\n        children = toArray(nativeNode.assignedNodes());\n    }\n    else if (isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n        ((_a = nativeNode.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {\n        children = toArray(nativeNode.contentDocument.body.childNodes);\n    }\n    else {\n        children = toArray(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes);\n    }\n    if (children.length === 0 ||\n        isInstanceOfElement(nativeNode, HTMLVideoElement)) {\n        return clonedNode;\n    }\n    await children.reduce((deferred, child) => deferred\n        .then(() => cloneNode(child, options))\n        .then((clonedChild) => {\n        if (clonedChild) {\n            clonedNode.appendChild(clonedChild);\n        }\n    }), Promise.resolve());\n    return clonedNode;\n}\nfunction cloneCSSStyle(nativeNode, clonedNode) {\n    const targetStyle = clonedNode.style;\n    if (!targetStyle) {\n        return;\n    }\n    const sourceStyle = window.getComputedStyle(nativeNode);\n    if (sourceStyle.cssText) {\n        targetStyle.cssText = sourceStyle.cssText;\n        targetStyle.transformOrigin = sourceStyle.transformOrigin;\n    }\n    else {\n        toArray(sourceStyle).forEach((name) => {\n            let value = sourceStyle.getPropertyValue(name);\n            if (name === 'font-size' && value.endsWith('px')) {\n                const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;\n                value = `${reducedFont}px`;\n            }\n            if (isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n                name === 'display' &&\n                value === 'inline') {\n                value = 'block';\n            }\n            if (name === 'd' && clonedNode.getAttribute('d')) {\n                value = `path(${clonedNode.getAttribute('d')})`;\n            }\n            targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));\n        });\n    }\n}\nfunction cloneInputValue(nativeNode, clonedNode) {\n    if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {\n        clonedNode.innerHTML = nativeNode.value;\n    }\n    if (isInstanceOfElement(nativeNode, HTMLInputElement)) {\n        clonedNode.setAttribute('value', nativeNode.value);\n    }\n}\nfunction cloneSelectValue(nativeNode, clonedNode) {\n    if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {\n        const clonedSelect = clonedNode;\n        const selectedOption = Array.from(clonedSelect.children).find((child) => nativeNode.value === child.getAttribute('value'));\n        if (selectedOption) {\n            selectedOption.setAttribute('selected', '');\n        }\n    }\n}\nfunction decorate(nativeNode, clonedNode) {\n    if (isInstanceOfElement(clonedNode, Element)) {\n        cloneCSSStyle(nativeNode, clonedNode);\n        clonePseudoElements(nativeNode, clonedNode);\n        cloneInputValue(nativeNode, clonedNode);\n        cloneSelectValue(nativeNode, clonedNode);\n    }\n    return clonedNode;\n}\nasync function ensureSVGSymbols(clone, options) {\n    const uses = clone.querySelectorAll ? clone.querySelectorAll('use') : [];\n    if (uses.length === 0) {\n        return clone;\n    }\n    const processedDefs = {};\n    for (let i = 0; i < uses.length; i++) {\n        const use = uses[i];\n        const id = use.getAttribute('xlink:href');\n        if (id) {\n            const exist = clone.querySelector(id);\n            const definition = document.querySelector(id);\n            if (!exist && definition && !processedDefs[id]) {\n                // eslint-disable-next-line no-await-in-loop\n                processedDefs[id] = (await cloneNode(definition, options, true));\n            }\n        }\n    }\n    const nodes = Object.values(processedDefs);\n    if (nodes.length) {\n        const ns = 'http://www.w3.org/1999/xhtml';\n        const svg = document.createElementNS(ns, 'svg');\n        svg.setAttribute('xmlns', ns);\n        svg.style.position = 'absolute';\n        svg.style.width = '0';\n        svg.style.height = '0';\n        svg.style.overflow = 'hidden';\n        svg.style.display = 'none';\n        const defs = document.createElementNS(ns, 'defs');\n        svg.appendChild(defs);\n        for (let i = 0; i < nodes.length; i++) {\n            defs.appendChild(nodes[i]);\n        }\n        clone.appendChild(svg);\n    }\n    return clone;\n}\nexport async function cloneNode(node, options, isRoot) {\n    if (!isRoot && options.filter && !options.filter(node)) {\n        return null;\n    }\n    return Promise.resolve(node)\n        .then((clonedNode) => cloneSingleNode(clonedNode, options))\n        .then((clonedNode) => cloneChildren(node, clonedNode, options))\n        .then((clonedNode) => decorate(node, clonedNode))\n        .then((clonedNode) => ensureSVGSymbols(clonedNode, options));\n}\n//# sourceMappingURL=clone-node.js.map","import type { Options } from './types'\nimport { clonePseudoElements } from './clone-pseudos'\nimport { createImage, toArray, isInstanceOfElement } from './util'\nimport { getMimeType } from './mimes'\nimport { resourceToDataURL } from './dataurl'\n\nasync function cloneCanvasElement(canvas: HTMLCanvasElement) {\n  const dataURL = canvas.toDataURL()\n  if (dataURL === 'data:,') {\n    return canvas.cloneNode(false) as HTMLCanvasElement\n  }\n  return createImage(dataURL)\n}\n\nasync function cloneVideoElement(video: HTMLVideoElement, options: Options) {\n  if (video.currentSrc) {\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d')\n    canvas.width = video.clientWidth\n    canvas.height = video.clientHeight\n    ctx?.drawImage(video, 0, 0, canvas.width, canvas.height)\n    const dataURL = canvas.toDataURL()\n    return createImage(dataURL)\n  }\n\n  const poster = video.poster\n  const contentType = getMimeType(poster)\n  const dataURL = await resourceToDataURL(poster, contentType, options)\n  return createImage(dataURL)\n}\n\nasync function cloneIFrameElement(iframe: HTMLIFrameElement) {\n  try {\n    if (iframe?.contentDocument?.body) {\n      return (await cloneNode(\n        iframe.contentDocument.body,\n        {},\n        true,\n      )) as HTMLBodyElement\n    }\n  } catch {\n    // Failed to clone iframe\n  }\n\n  return iframe.cloneNode(false) as HTMLIFrameElement\n}\n\nasync function cloneSingleNode<T extends HTMLElement>(\n  node: T,\n  options: Options,\n): Promise<HTMLElement> {\n  if (isInstanceOfElement(node, HTMLCanvasElement)) {\n    return cloneCanvasElement(node)\n  }\n\n  if (isInstanceOfElement(node, HTMLVideoElement)) {\n    return cloneVideoElement(node, options)\n  }\n\n  if (isInstanceOfElement(node, HTMLIFrameElement)) {\n    return cloneIFrameElement(node)\n  }\n\n  return node.cloneNode(false) as T\n}\n\nconst isSlotElement = (node: HTMLElement): node is HTMLSlotElement =>\n  node.tagName != null && node.tagName.toUpperCase() === 'SLOT'\n\nasync function cloneChildren<T extends HTMLElement>(\n  nativeNode: T,\n  clonedNode: T,\n  options: Options,\n): Promise<T> {\n  let children: T[] = []\n\n  if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {\n    children = toArray<T>(nativeNode.assignedNodes())\n  } else if (\n    isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n    nativeNode.contentDocument?.body\n  ) {\n    children = toArray<T>(nativeNode.contentDocument.body.childNodes)\n  } else {\n    children = toArray<T>((nativeNode.shadowRoot ?? nativeNode).childNodes)\n  }\n\n  if (\n    children.length === 0 ||\n    isInstanceOfElement(nativeNode, HTMLVideoElement)\n  ) {\n    return clonedNode\n  }\n\n  await children.reduce(\n    (deferred, child) =>\n      deferred\n        .then(() => cloneNode(child, options))\n        .then((clonedChild: HTMLElement | null) => {\n          if (clonedChild) {\n            clonedNode.appendChild(clonedChild)\n          }\n        }),\n    Promise.resolve(),\n  )\n\n  return clonedNode\n}\n\nfunction cloneCSSStyle<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n  const targetStyle = clonedNode.style\n  if (!targetStyle) {\n    return\n  }\n\n  const sourceStyle = window.getComputedStyle(nativeNode)\n  if (sourceStyle.cssText) {\n    targetStyle.cssText = sourceStyle.cssText\n    targetStyle.transformOrigin = sourceStyle.transformOrigin\n  } else {\n    toArray<string>(sourceStyle).forEach((name) => {\n      let value = sourceStyle.getPropertyValue(name)\n      if (name === 'font-size' && value.endsWith('px')) {\n        const reducedFont =\n          Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1\n        value = `${reducedFont}px`\n      }\n\n      if (\n        isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n        name === 'display' &&\n        value === 'inline'\n      ) {\n        value = 'block'\n      }\n      \n      if (name === 'd' && clonedNode.getAttribute('d')) {\n        value = `path(${clonedNode.getAttribute('d')})`\n      }\n      \n      targetStyle.setProperty(\n        name,\n        value,\n        sourceStyle.getPropertyPriority(name),\n      )\n    })\n  }\n}\n\nfunction cloneInputValue<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n  if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {\n    clonedNode.innerHTML = nativeNode.value\n  }\n\n  if (isInstanceOfElement(nativeNode, HTMLInputElement)) {\n    clonedNode.setAttribute('value', nativeNode.value)\n  }\n}\n\nfunction cloneSelectValue<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n  if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {\n    const clonedSelect = clonedNode as any as HTMLSelectElement\n    const selectedOption = Array.from(clonedSelect.children).find(\n      (child) => nativeNode.value === child.getAttribute('value'),\n    )\n\n    if (selectedOption) {\n      selectedOption.setAttribute('selected', '')\n    }\n  }\n}\n\nfunction decorate<T extends HTMLElement>(nativeNode: T, clonedNode: T): T {\n  if (isInstanceOfElement(clonedNode, Element)) {\n    cloneCSSStyle(nativeNode, clonedNode)\n    clonePseudoElements(nativeNode, clonedNode)\n    cloneInputValue(nativeNode, clonedNode)\n    cloneSelectValue(nativeNode, clonedNode)\n  }\n\n  return clonedNode\n}\n\nasync function ensureSVGSymbols<T extends HTMLElement>(\n  clone: T,\n  options: Options,\n) {\n  const uses = clone.querySelectorAll ? clone.querySelectorAll('use') : []\n  if (uses.length === 0) {\n    return clone\n  }\n\n  const processedDefs: { [key: string]: HTMLElement } = {}\n  for (let i = 0; i < uses.length; i++) {\n    const use = uses[i]\n    const id = use.getAttribute('xlink:href')\n    if (id) {\n      const exist = clone.querySelector(id)\n      const definition = document.querySelector(id) as HTMLElement\n      if (!exist && definition && !processedDefs[id]) {\n        // eslint-disable-next-line no-await-in-loop\n        processedDefs[id] = (await cloneNode(definition, options, true))!\n      }\n    }\n  }\n\n  const nodes = Object.values(processedDefs)\n  if (nodes.length) {\n    const ns = 'http://www.w3.org/1999/xhtml'\n    const svg = document.createElementNS(ns, 'svg')\n    svg.setAttribute('xmlns', ns)\n    svg.style.position = 'absolute'\n    svg.style.width = '0'\n    svg.style.height = '0'\n    svg.style.overflow = 'hidden'\n    svg.style.display = 'none'\n\n    const defs = document.createElementNS(ns, 'defs')\n    svg.appendChild(defs)\n\n    for (let i = 0; i < nodes.length; i++) {\n      defs.appendChild(nodes[i])\n    }\n\n    clone.appendChild(svg)\n  }\n\n  return clone\n}\n\nexport async function cloneNode<T extends HTMLElement>(\n  node: T,\n  options: Options,\n  isRoot?: boolean,\n): Promise<T | null> {\n  if (!isRoot && options.filter && !options.filter(node)) {\n    return null\n  }\n\n  return Promise.resolve(node)\n    .then((clonedNode) => cloneSingleNode(clonedNode, options) as Promise<T>)\n    .then((clonedNode) => cloneChildren(node, clonedNode, options))\n    .then((clonedNode) => decorate(node, clonedNode))\n    .then((clonedNode) => ensureSVGSymbols(clonedNode, options))\n}\n","import { uuid, toArray } from './util';\nfunction formatCSSText(style) {\n    const content = style.getPropertyValue('content');\n    return `${style.cssText} content: '${content.replace(/'|\"/g, '')}';`;\n}\nfunction formatCSSProperties(style) {\n    return toArray(style)\n        .map((name) => {\n        const value = style.getPropertyValue(name);\n        const priority = style.getPropertyPriority(name);\n        return `${name}: ${value}${priority ? ' !important' : ''};`;\n    })\n        .join(' ');\n}\nfunction getPseudoElementStyle(className, pseudo, style) {\n    const selector = `.${className}:${pseudo}`;\n    const cssText = style.cssText\n        ? formatCSSText(style)\n        : formatCSSProperties(style);\n    return document.createTextNode(`${selector}{${cssText}}`);\n}\nfunction clonePseudoElement(nativeNode, clonedNode, pseudo) {\n    const style = window.getComputedStyle(nativeNode, pseudo);\n    const content = style.getPropertyValue('content');\n    if (content === '' || content === 'none') {\n        return;\n    }\n    const className = uuid();\n    try {\n        clonedNode.className = `${clonedNode.className} ${className}`;\n    }\n    catch (err) {\n        return;\n    }\n    const styleElement = document.createElement('style');\n    styleElement.appendChild(getPseudoElementStyle(className, pseudo, style));\n    clonedNode.appendChild(styleElement);\n}\nexport function clonePseudoElements(nativeNode, clonedNode) {\n    clonePseudoElement(nativeNode, clonedNode, ':before');\n    clonePseudoElement(nativeNode, clonedNode, ':after');\n}\n//# sourceMappingURL=clone-pseudos.js.map","import { uuid, toArray } from './util'\n\ntype Pseudo = ':before' | ':after'\n\nfunction formatCSSText(style: CSSStyleDeclaration) {\n  const content = style.getPropertyValue('content')\n  return `${style.cssText} content: '${content.replace(/'|\"/g, '')}';`\n}\n\nfunction formatCSSProperties(style: CSSStyleDeclaration) {\n  return toArray<string>(style)\n    .map((name) => {\n      const value = style.getPropertyValue(name)\n      const priority = style.getPropertyPriority(name)\n\n      return `${name}: ${value}${priority ? ' !important' : ''};`\n    })\n    .join(' ')\n}\n\nfunction getPseudoElementStyle(\n  className: string,\n  pseudo: Pseudo,\n  style: CSSStyleDeclaration,\n): Text {\n  const selector = `.${className}:${pseudo}`\n  const cssText = style.cssText\n    ? formatCSSText(style)\n    : formatCSSProperties(style)\n\n  return document.createTextNode(`${selector}{${cssText}}`)\n}\n\nfunction clonePseudoElement<T extends HTMLElement>(\n  nativeNode: T,\n  clonedNode: T,\n  pseudo: Pseudo,\n) {\n  const style = window.getComputedStyle(nativeNode, pseudo)\n  const content = style.getPropertyValue('content')\n  if (content === '' || content === 'none') {\n    return\n  }\n\n  const className = uuid()\n  try {\n    clonedNode.className = `${clonedNode.className} ${className}`\n  } catch (err) {\n    return\n  }\n\n  const styleElement = document.createElement('style')\n  styleElement.appendChild(getPseudoElementStyle(className, pseudo, style))\n  clonedNode.appendChild(styleElement)\n}\n\nexport function clonePseudoElements<T extends HTMLElement>(\n  nativeNode: T,\n  clonedNode: T,\n) {\n  clonePseudoElement(nativeNode, clonedNode, ':before')\n  clonePseudoElement(nativeNode, clonedNode, ':after')\n}\n","export function resolveUrl(url, baseUrl) {\n    // url is absolute already\n    if (url.match(/^[a-z]+:\\/\\//i)) {\n        return url;\n    }\n    // url is absolute already, without protocol\n    if (url.match(/^\\/\\//)) {\n        return window.location.protocol + url;\n    }\n    // dataURI, mailto:, tel:, etc.\n    if (url.match(/^[a-z]+:/i)) {\n        return url;\n    }\n    const doc = document.implementation.createHTMLDocument();\n    const base = doc.createElement('base');\n    const a = doc.createElement('a');\n    doc.head.appendChild(base);\n    doc.body.appendChild(a);\n    if (baseUrl) {\n        base.href = baseUrl;\n    }\n    a.href = url;\n    return a.href;\n}\nexport const uuid = (() => {\n    // generate uuid for className of pseudo elements.\n    // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.\n    let counter = 0;\n    // ref: http://stackoverflow.com/a/6248722/2519373\n    const random = () => \n    // eslint-disable-next-line no-bitwise\n    `0000${((Math.random() * 36 ** 4) << 0).toString(36)}`.slice(-4);\n    return () => {\n        counter += 1;\n        return `u${random()}${counter}`;\n    };\n})();\nexport function delay(ms) {\n    return (args) => new Promise((resolve) => {\n        setTimeout(() => resolve(args), ms);\n    });\n}\nexport function toArray(arrayLike) {\n    const arr = [];\n    for (let i = 0, l = arrayLike.length; i < l; i++) {\n        arr.push(arrayLike[i]);\n    }\n    return arr;\n}\nfunction px(node, styleProperty) {\n    const win = node.ownerDocument.defaultView || window;\n    const val = win.getComputedStyle(node).getPropertyValue(styleProperty);\n    return val ? parseFloat(val.replace('px', '')) : 0;\n}\nfunction getNodeWidth(node) {\n    const leftBorder = px(node, 'border-left-width');\n    const rightBorder = px(node, 'border-right-width');\n    return node.clientWidth + leftBorder + rightBorder;\n}\nfunction getNodeHeight(node) {\n    const topBorder = px(node, 'border-top-width');\n    const bottomBorder = px(node, 'border-bottom-width');\n    return node.clientHeight + topBorder + bottomBorder;\n}\nexport function getImageSize(targetNode, options = {}) {\n    const width = options.width || getNodeWidth(targetNode);\n    const height = options.height || getNodeHeight(targetNode);\n    return { width, height };\n}\nexport function getPixelRatio() {\n    let ratio;\n    let FINAL_PROCESS;\n    try {\n        FINAL_PROCESS = process;\n    }\n    catch (e) {\n        // pass\n    }\n    const val = FINAL_PROCESS && FINAL_PROCESS.env\n        ? FINAL_PROCESS.env.devicePixelRatio\n        : null;\n    if (val) {\n        ratio = parseInt(val, 10);\n        if (Number.isNaN(ratio)) {\n            ratio = 1;\n        }\n    }\n    return ratio || window.devicePixelRatio || 1;\n}\n// @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\nconst canvasDimensionLimit = 16384;\nexport function checkCanvasDimensions(canvas) {\n    if (canvas.width > canvasDimensionLimit ||\n        canvas.height > canvasDimensionLimit) {\n        if (canvas.width > canvasDimensionLimit &&\n            canvas.height > canvasDimensionLimit) {\n            if (canvas.width > canvas.height) {\n                canvas.height *= canvasDimensionLimit / canvas.width;\n                canvas.width = canvasDimensionLimit;\n            }\n            else {\n                canvas.width *= canvasDimensionLimit / canvas.height;\n                canvas.height = canvasDimensionLimit;\n            }\n        }\n        else if (canvas.width > canvasDimensionLimit) {\n            canvas.height *= canvasDimensionLimit / canvas.width;\n            canvas.width = canvasDimensionLimit;\n        }\n        else {\n            canvas.width *= canvasDimensionLimit / canvas.height;\n            canvas.height = canvasDimensionLimit;\n        }\n    }\n}\nexport function canvasToBlob(canvas, options = {}) {\n    if (canvas.toBlob) {\n        return new Promise((resolve) => {\n            canvas.toBlob(resolve, options.type ? options.type : 'image/png', options.quality ? options.quality : 1);\n        });\n    }\n    return new Promise((resolve) => {\n        const binaryString = window.atob(canvas\n            .toDataURL(options.type ? options.type : undefined, options.quality ? options.quality : undefined)\n            .split(',')[1]);\n        const len = binaryString.length;\n        const binaryArray = new Uint8Array(len);\n        for (let i = 0; i < len; i += 1) {\n            binaryArray[i] = binaryString.charCodeAt(i);\n        }\n        resolve(new Blob([binaryArray], {\n            type: options.type ? options.type : 'image/png',\n        }));\n    });\n}\nexport function createImage(url) {\n    return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.decode = () => resolve(img);\n        img.onload = () => resolve(img);\n        img.onerror = reject;\n        img.crossOrigin = 'anonymous';\n        img.decoding = 'async';\n        img.src = url;\n    });\n}\nexport async function svgToDataURL(svg) {\n    return Promise.resolve()\n        .then(() => new XMLSerializer().serializeToString(svg))\n        .then(encodeURIComponent)\n        .then((html) => `data:image/svg+xml;charset=utf-8,${html}`);\n}\nexport async function nodeToDataURL(node, width, height) {\n    const xmlns = 'http://www.w3.org/2000/svg';\n    const svg = document.createElementNS(xmlns, 'svg');\n    const foreignObject = document.createElementNS(xmlns, 'foreignObject');\n    svg.setAttribute('width', `${width}`);\n    svg.setAttribute('height', `${height}`);\n    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n    foreignObject.setAttribute('width', '100%');\n    foreignObject.setAttribute('height', '100%');\n    foreignObject.setAttribute('x', '0');\n    foreignObject.setAttribute('y', '0');\n    foreignObject.setAttribute('externalResourcesRequired', 'true');\n    svg.appendChild(foreignObject);\n    foreignObject.appendChild(node);\n    return svgToDataURL(svg);\n}\nexport const isInstanceOfElement = (node, instance) => {\n    if (node instanceof instance)\n        return true;\n    const nodePrototype = Object.getPrototypeOf(node);\n    if (nodePrototype === null)\n        return false;\n    return (nodePrototype.constructor.name === instance.name ||\n        isInstanceOfElement(nodePrototype, instance));\n};\n//# sourceMappingURL=util.js.map","import type { Options } from './types'\n\nexport function resolveUrl(url: string, baseUrl: string | null): string {\n  // url is absolute already\n  if (url.match(/^[a-z]+:\\/\\//i)) {\n    return url\n  }\n\n  // url is absolute already, without protocol\n  if (url.match(/^\\/\\//)) {\n    return window.location.protocol + url\n  }\n\n  // dataURI, mailto:, tel:, etc.\n  if (url.match(/^[a-z]+:/i)) {\n    return url\n  }\n\n  const doc = document.implementation.createHTMLDocument()\n  const base = doc.createElement('base')\n  const a = doc.createElement('a')\n\n  doc.head.appendChild(base)\n  doc.body.appendChild(a)\n\n  if (baseUrl) {\n    base.href = baseUrl\n  }\n\n  a.href = url\n\n  return a.href\n}\n\nexport const uuid = (() => {\n  // generate uuid for className of pseudo elements.\n  // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.\n  let counter = 0\n\n  // ref: http://stackoverflow.com/a/6248722/2519373\n  const random = () =>\n    // eslint-disable-next-line no-bitwise\n    `0000${((Math.random() * 36 ** 4) << 0).toString(36)}`.slice(-4)\n\n  return () => {\n    counter += 1\n    return `u${random()}${counter}`\n  }\n})()\n\nexport function delay<T>(ms: number) {\n  return (args: T) =>\n    new Promise<T>((resolve) => {\n      setTimeout(() => resolve(args), ms)\n    })\n}\n\nexport function toArray<T>(arrayLike: any): T[] {\n  const arr: T[] = []\n\n  for (let i = 0, l = arrayLike.length; i < l; i++) {\n    arr.push(arrayLike[i])\n  }\n\n  return arr\n}\n\nfunction px(node: HTMLElement, styleProperty: string) {\n  const win = node.ownerDocument.defaultView || window\n  const val = win.getComputedStyle(node).getPropertyValue(styleProperty)\n  return val ? parseFloat(val.replace('px', '')) : 0\n}\n\nfunction getNodeWidth(node: HTMLElement) {\n  const leftBorder = px(node, 'border-left-width')\n  const rightBorder = px(node, 'border-right-width')\n  return node.clientWidth + leftBorder + rightBorder\n}\n\nfunction getNodeHeight(node: HTMLElement) {\n  const topBorder = px(node, 'border-top-width')\n  const bottomBorder = px(node, 'border-bottom-width')\n  return node.clientHeight + topBorder + bottomBorder\n}\n\nexport function getImageSize(targetNode: HTMLElement, options: Options = {}) {\n  const width = options.width || getNodeWidth(targetNode)\n  const height = options.height || getNodeHeight(targetNode)\n\n  return { width, height }\n}\n\nexport function getPixelRatio() {\n  let ratio\n\n  let FINAL_PROCESS\n  try {\n    FINAL_PROCESS = process\n  } catch (e) {\n    // pass\n  }\n\n  const val =\n    FINAL_PROCESS && FINAL_PROCESS.env\n      ? FINAL_PROCESS.env.devicePixelRatio\n      : null\n  if (val) {\n    ratio = parseInt(val, 10)\n    if (Number.isNaN(ratio)) {\n      ratio = 1\n    }\n  }\n  return ratio || window.devicePixelRatio || 1\n}\n\n// @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\nconst canvasDimensionLimit = 16384\n\nexport function checkCanvasDimensions(canvas: HTMLCanvasElement) {\n  if (\n    canvas.width > canvasDimensionLimit ||\n    canvas.height > canvasDimensionLimit\n  ) {\n    if (\n      canvas.width > canvasDimensionLimit &&\n      canvas.height > canvasDimensionLimit\n    ) {\n      if (canvas.width > canvas.height) {\n        canvas.height *= canvasDimensionLimit / canvas.width\n        canvas.width = canvasDimensionLimit\n      } else {\n        canvas.width *= canvasDimensionLimit / canvas.height\n        canvas.height = canvasDimensionLimit\n      }\n    } else if (canvas.width > canvasDimensionLimit) {\n      canvas.height *= canvasDimensionLimit / canvas.width\n      canvas.width = canvasDimensionLimit\n    } else {\n      canvas.width *= canvasDimensionLimit / canvas.height\n      canvas.height = canvasDimensionLimit\n    }\n  }\n}\n\nexport function canvasToBlob(\n  canvas: HTMLCanvasElement,\n  options: Options = {},\n): Promise<Blob | null> {\n  if (canvas.toBlob) {\n    return new Promise((resolve) => {\n      canvas.toBlob(\n        resolve,\n        options.type ? options.type : 'image/png',\n        options.quality ? options.quality : 1,\n      )\n    })\n  }\n\n  return new Promise((resolve) => {\n    const binaryString = window.atob(\n      canvas\n        .toDataURL(\n          options.type ? options.type : undefined,\n          options.quality ? options.quality : undefined,\n        )\n        .split(',')[1],\n    )\n    const len = binaryString.length\n    const binaryArray = new Uint8Array(len)\n\n    for (let i = 0; i < len; i += 1) {\n      binaryArray[i] = binaryString.charCodeAt(i)\n    }\n\n    resolve(\n      new Blob([binaryArray], {\n        type: options.type ? options.type : 'image/png',\n      }),\n    )\n  })\n}\n\nexport function createImage(url: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image()\n    img.decode = () => resolve(img) as any\n    img.onload = () => resolve(img)\n    img.onerror = reject\n    img.crossOrigin = 'anonymous'\n    img.decoding = 'async'\n    img.src = url\n  })\n}\n\nexport async function svgToDataURL(svg: SVGElement): Promise<string> {\n  return Promise.resolve()\n    .then(() => new XMLSerializer().serializeToString(svg))\n    .then(encodeURIComponent)\n    .then((html) => `data:image/svg+xml;charset=utf-8,${html}`)\n}\n\nexport async function nodeToDataURL(\n  node: HTMLElement,\n  width: number,\n  height: number,\n): Promise<string> {\n  const xmlns = 'http://www.w3.org/2000/svg'\n  const svg = document.createElementNS(xmlns, 'svg')\n  const foreignObject = document.createElementNS(xmlns, 'foreignObject')\n\n  svg.setAttribute('width', `${width}`)\n  svg.setAttribute('height', `${height}`)\n  svg.setAttribute('viewBox', `0 0 ${width} ${height}`)\n\n  foreignObject.setAttribute('width', '100%')\n  foreignObject.setAttribute('height', '100%')\n  foreignObject.setAttribute('x', '0')\n  foreignObject.setAttribute('y', '0')\n  foreignObject.setAttribute('externalResourcesRequired', 'true')\n\n  svg.appendChild(foreignObject)\n  foreignObject.appendChild(node)\n  return svgToDataURL(svg)\n}\n\nexport const isInstanceOfElement = <\n  T extends typeof Element | typeof HTMLElement | typeof SVGImageElement,\n>(\n  node: Element | HTMLElement | SVGImageElement,\n  instance: T,\n): node is T['prototype'] => {\n  if (node instanceof instance) return true\n\n  const nodePrototype = Object.getPrototypeOf(node)\n\n  if (nodePrototype === null) return false\n\n  return (\n    nodePrototype.constructor.name === instance.name ||\n    isInstanceOfElement(nodePrototype, instance)\n  )\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","const WOFF = 'application/font-woff';\nconst JPEG = 'image/jpeg';\nconst mimes = {\n    woff: WOFF,\n    woff2: WOFF,\n    ttf: 'application/font-truetype',\n    eot: 'application/vnd.ms-fontobject',\n    png: 'image/png',\n    jpg: JPEG,\n    jpeg: JPEG,\n    gif: 'image/gif',\n    tiff: 'image/tiff',\n    svg: 'image/svg+xml',\n    webp: 'image/webp',\n};\nfunction getExtension(url) {\n    const match = /\\.([^./]*?)$/g.exec(url);\n    return match ? match[1] : '';\n}\nexport function getMimeType(url) {\n    const extension = getExtension(url).toLowerCase();\n    return mimes[extension] || '';\n}\n//# sourceMappingURL=mimes.js.map","const WOFF = 'application/font-woff'\nconst JPEG = 'image/jpeg'\nconst mimes: { [key: string]: string } = {\n  woff: WOFF,\n  woff2: WOFF,\n  ttf: 'application/font-truetype',\n  eot: 'application/vnd.ms-fontobject',\n  png: 'image/png',\n  jpg: JPEG,\n  jpeg: JPEG,\n  gif: 'image/gif',\n  tiff: 'image/tiff',\n  svg: 'image/svg+xml',\n  webp: 'image/webp',\n}\n\nfunction getExtension(url: string): string {\n  const match = /\\.([^./]*?)$/g.exec(url)\n  return match ? match[1] : ''\n}\n\nexport function getMimeType(url: string): string {\n  const extension = getExtension(url).toLowerCase()\n  return mimes[extension] || ''\n}\n","function getContentFromDataUrl(dataURL) {\n    return dataURL.split(/,/)[1];\n}\nexport function isDataUrl(url) {\n    return url.search(/^(data:)/) !== -1;\n}\nexport function makeDataUrl(content, mimeType) {\n    return `data:${mimeType};base64,${content}`;\n}\nexport async function fetchAsDataURL(url, init, process) {\n    const res = await fetch(url, init);\n    if (res.status === 404) {\n        throw new Error(`Resource \"${res.url}\" not found`);\n    }\n    const blob = await res.blob();\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = () => {\n            try {\n                resolve(process({ res, result: reader.result }));\n            }\n            catch (error) {\n                reject(error);\n            }\n        };\n        reader.readAsDataURL(blob);\n    });\n}\nconst cache = {};\nfunction getCacheKey(url, contentType, includeQueryParams) {\n    let key = url.replace(/\\?.*/, '');\n    if (includeQueryParams) {\n        key = url;\n    }\n    // font resource\n    if (/ttf|otf|eot|woff2?/i.test(key)) {\n        key = key.replace(/.*\\//, '');\n    }\n    return contentType ? `[${contentType}]${key}` : key;\n}\nexport async function resourceToDataURL(resourceUrl, contentType, options) {\n    const cacheKey = getCacheKey(resourceUrl, contentType, options.includeQueryParams);\n    if (cache[cacheKey] != null) {\n        return cache[cacheKey];\n    }\n    // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n    if (options.cacheBust) {\n        // eslint-disable-next-line no-param-reassign\n        resourceUrl += (/\\?/.test(resourceUrl) ? '&' : '?') + new Date().getTime();\n    }\n    let dataURL;\n    try {\n        const content = await fetchAsDataURL(resourceUrl, options.fetchRequestInit, ({ res, result }) => {\n            if (!contentType) {\n                // eslint-disable-next-line no-param-reassign\n                contentType = res.headers.get('Content-Type') || '';\n            }\n            return getContentFromDataUrl(result);\n        });\n        dataURL = makeDataUrl(content, contentType);\n    }\n    catch (error) {\n        dataURL = options.imagePlaceholder || '';\n        let msg = `Failed to fetch resource: ${resourceUrl}`;\n        if (error) {\n            msg = typeof error === 'string' ? error : error.message;\n        }\n        if (msg) {\n            console.warn(msg);\n        }\n    }\n    cache[cacheKey] = dataURL;\n    return dataURL;\n}\n//# sourceMappingURL=dataurl.js.map","import { Options } from './types'\n\nfunction getContentFromDataUrl(dataURL: string) {\n  return dataURL.split(/,/)[1]\n}\n\nexport function isDataUrl(url: string) {\n  return url.search(/^(data:)/) !== -1\n}\n\nexport function makeDataUrl(content: string, mimeType: string) {\n  return `data:${mimeType};base64,${content}`\n}\n\nexport async function fetchAsDataURL<T>(\n  url: string,\n  init: RequestInit | undefined,\n  process: (data: { result: string; res: Response }) => T,\n): Promise<T> {\n  const res = await fetch(url, init)\n  if (res.status === 404) {\n    throw new Error(`Resource \"${res.url}\" not found`)\n  }\n  const blob = await res.blob()\n  return new Promise<T>((resolve, reject) => {\n    const reader = new FileReader()\n    reader.onerror = reject\n    reader.onloadend = () => {\n      try {\n        resolve(process({ res, result: reader.result as string }))\n      } catch (error) {\n        reject(error)\n      }\n    }\n\n    reader.readAsDataURL(blob)\n  })\n}\n\nconst cache: { [url: string]: string } = {}\n\nfunction getCacheKey(\n  url: string,\n  contentType: string | undefined,\n  includeQueryParams: boolean | undefined,\n) {\n  let key = url.replace(/\\?.*/, '')\n\n  if (includeQueryParams) {\n    key = url\n  }\n\n  // font resource\n  if (/ttf|otf|eot|woff2?/i.test(key)) {\n    key = key.replace(/.*\\//, '')\n  }\n\n  return contentType ? `[${contentType}]${key}` : key\n}\n\nexport async function resourceToDataURL(\n  resourceUrl: string,\n  contentType: string | undefined,\n  options: Options,\n) {\n  const cacheKey = getCacheKey(\n    resourceUrl,\n    contentType,\n    options.includeQueryParams,\n  )\n\n  if (cache[cacheKey] != null) {\n    return cache[cacheKey]\n  }\n\n  // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n  if (options.cacheBust) {\n    // eslint-disable-next-line no-param-reassign\n    resourceUrl += (/\\?/.test(resourceUrl) ? '&' : '?') + new Date().getTime()\n  }\n\n  let dataURL: string\n  try {\n    const content = await fetchAsDataURL(\n      resourceUrl,\n      options.fetchRequestInit,\n      ({ res, result }) => {\n        if (!contentType) {\n          // eslint-disable-next-line no-param-reassign\n          contentType = res.headers.get('Content-Type') || ''\n        }\n        return getContentFromDataUrl(result)\n      },\n    )\n    dataURL = makeDataUrl(content, contentType!)\n  } catch (error) {\n    dataURL = options.imagePlaceholder || ''\n\n    let msg = `Failed to fetch resource: ${resourceUrl}`\n    if (error) {\n      msg = typeof error === 'string' ? error : error.message\n    }\n\n    if (msg) {\n      console.warn(msg)\n    }\n  }\n\n  cache[cacheKey] = dataURL\n  return dataURL\n}\n","import { embedResources } from './embed-resources';\nimport { toArray, isInstanceOfElement } from './util';\nimport { isDataUrl, resourceToDataURL } from './dataurl';\nimport { getMimeType } from './mimes';\nasync function embedProp(propName, node, options) {\n    var _a;\n    const propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);\n    if (propValue) {\n        const cssString = await embedResources(propValue, null, options);\n        node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));\n        return true;\n    }\n    return false;\n}\nasync function embedBackground(clonedNode, options) {\n    if (!(await embedProp('background', clonedNode, options))) {\n        await embedProp('background-image', clonedNode, options);\n    }\n    if (!(await embedProp('mask', clonedNode, options))) {\n        await embedProp('mask-image', clonedNode, options);\n    }\n}\nasync function embedImageNode(clonedNode, options) {\n    const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);\n    if (!(isImageElement && !isDataUrl(clonedNode.src)) &&\n        !(isInstanceOfElement(clonedNode, SVGImageElement) &&\n            !isDataUrl(clonedNode.href.baseVal))) {\n        return;\n    }\n    const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;\n    const dataURL = await resourceToDataURL(url, getMimeType(url), options);\n    await new Promise((resolve, reject) => {\n        clonedNode.onload = resolve;\n        clonedNode.onerror = reject;\n        const image = clonedNode;\n        if (image.decode) {\n            image.decode = resolve;\n        }\n        if (image.loading === 'lazy') {\n            image.loading = 'eager';\n        }\n        if (isImageElement) {\n            clonedNode.srcset = '';\n            clonedNode.src = dataURL;\n        }\n        else {\n            clonedNode.href.baseVal = dataURL;\n        }\n    });\n}\nasync function embedChildren(clonedNode, options) {\n    const children = toArray(clonedNode.childNodes);\n    const deferreds = children.map((child) => embedImages(child, options));\n    await Promise.all(deferreds).then(() => clonedNode);\n}\nexport async function embedImages(clonedNode, options) {\n    if (isInstanceOfElement(clonedNode, Element)) {\n        await embedBackground(clonedNode, options);\n        await embedImageNode(clonedNode, options);\n        await embedChildren(clonedNode, options);\n    }\n}\n//# sourceMappingURL=embed-images.js.map","import { Options } from './types'\nimport { embedResources } from './embed-resources'\nimport { toArray, isInstanceOfElement } from './util'\nimport { isDataUrl, resourceToDataURL } from './dataurl'\nimport { getMimeType } from './mimes'\n\nasync function embedProp(\n  propName: string,\n  node: HTMLElement,\n  options: Options,\n) {\n  const propValue = node.style?.getPropertyValue(propName)\n  if (propValue) {\n    const cssString = await embedResources(propValue, null, options)\n    node.style.setProperty(\n      propName,\n      cssString,\n      node.style.getPropertyPriority(propName),\n    )\n    return true\n  }\n  return false\n}\n\nasync function embedBackground<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  if (!(await embedProp('background', clonedNode, options))) {\n    await embedProp('background-image', clonedNode, options)\n  }\n  if (!(await embedProp('mask', clonedNode, options))) {\n    await embedProp('mask-image', clonedNode, options)\n  }\n}\n\nasync function embedImageNode<T extends HTMLElement | SVGImageElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement)\n\n  if (\n    !(isImageElement && !isDataUrl(clonedNode.src)) &&\n    !(\n      isInstanceOfElement(clonedNode, SVGImageElement) &&\n      !isDataUrl(clonedNode.href.baseVal)\n    )\n  ) {\n    return\n  }\n\n  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal\n\n  const dataURL = await resourceToDataURL(url, getMimeType(url), options)\n  await new Promise((resolve, reject) => {\n    clonedNode.onload = resolve\n    clonedNode.onerror = reject\n\n    const image = clonedNode as HTMLImageElement\n    if (image.decode) {\n      image.decode = resolve as any\n    }\n\n    if (image.loading === 'lazy') {\n      image.loading = 'eager'\n    }\n\n    if (isImageElement) {\n      clonedNode.srcset = ''\n      clonedNode.src = dataURL\n    } else {\n      clonedNode.href.baseVal = dataURL\n    }\n  })\n}\n\nasync function embedChildren<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const children = toArray<HTMLElement>(clonedNode.childNodes)\n  const deferreds = children.map((child) => embedImages(child, options))\n  await Promise.all(deferreds).then(() => clonedNode)\n}\n\nexport async function embedImages<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  if (isInstanceOfElement(clonedNode, Element)) {\n    await embedBackground(clonedNode, options)\n    await embedImageNode(clonedNode, options)\n    await embedChildren(clonedNode, options)\n  }\n}\n","import { resolveUrl } from './util';\nimport { getMimeType } from './mimes';\nimport { isDataUrl, makeDataUrl, resourceToDataURL } from './dataurl';\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"']?)([^\"']+)\\1\\)/g;\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nfunction toRegex(url) {\n    // eslint-disable-next-line no-useless-escape\n    const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n    return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, 'g');\n}\nexport function parseURLs(cssText) {\n    const urls = [];\n    cssText.replace(URL_REGEX, (raw, quotation, url) => {\n        urls.push(url);\n        return raw;\n    });\n    return urls.filter((url) => !isDataUrl(url));\n}\nexport async function embed(cssText, resourceURL, baseURL, options, getContentFromUrl) {\n    try {\n        const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;\n        const contentType = getMimeType(resourceURL);\n        let dataURL;\n        if (getContentFromUrl) {\n            const content = await getContentFromUrl(resolvedURL);\n            dataURL = makeDataUrl(content, contentType);\n        }\n        else {\n            dataURL = await resourceToDataURL(resolvedURL, contentType, options);\n        }\n        return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`);\n    }\n    catch (error) {\n        // pass\n    }\n    return cssText;\n}\nfunction filterPreferredFontFormat(str, { preferredFontFormat }) {\n    return !preferredFontFormat\n        ? str\n        : str.replace(FONT_SRC_REGEX, (match) => {\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];\n                if (!format) {\n                    return '';\n                }\n                if (format === preferredFontFormat) {\n                    return `src: ${src};`;\n                }\n            }\n        });\n}\nexport function shouldEmbed(url) {\n    return url.search(URL_REGEX) !== -1;\n}\nexport async function embedResources(cssText, baseUrl, options) {\n    if (!shouldEmbed(cssText)) {\n        return cssText;\n    }\n    const filteredCSSText = filterPreferredFontFormat(cssText, options);\n    const urls = parseURLs(filteredCSSText);\n    return urls.reduce((deferred, url) => deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText));\n}\n//# sourceMappingURL=embed-resources.js.map","import { Options } from './types'\nimport { resolveUrl } from './util'\nimport { getMimeType } from './mimes'\nimport { isDataUrl, makeDataUrl, resourceToDataURL } from './dataurl'\n\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"']?)([^\"']+)\\1\\)/g\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g\n\nfunction toRegex(url: string): RegExp {\n  // eslint-disable-next-line no-useless-escape\n  const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1')\n  return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, 'g')\n}\n\nexport function parseURLs(cssText: string): string[] {\n  const urls: string[] = []\n\n  cssText.replace(URL_REGEX, (raw, quotation, url) => {\n    urls.push(url)\n    return raw\n  })\n\n  return urls.filter((url) => !isDataUrl(url))\n}\n\nexport async function embed(\n  cssText: string,\n  resourceURL: string,\n  baseURL: string | null,\n  options: Options,\n  getContentFromUrl?: (url: string) => Promise<string>,\n): Promise<string> {\n  try {\n    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL\n    const contentType = getMimeType(resourceURL)\n    let dataURL: string\n    if (getContentFromUrl) {\n      const content = await getContentFromUrl(resolvedURL)\n      dataURL = makeDataUrl(content, contentType)\n    } else {\n      dataURL = await resourceToDataURL(resolvedURL, contentType, options)\n    }\n    return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`)\n  } catch (error) {\n    // pass\n  }\n  return cssText\n}\n\nfunction filterPreferredFontFormat(\n  str: string,\n  { preferredFontFormat }: Options,\n): string {\n  return !preferredFontFormat\n    ? str\n    : str.replace(FONT_SRC_REGEX, (match: string) => {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n          const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || []\n          if (!format) {\n            return ''\n          }\n\n          if (format === preferredFontFormat) {\n            return `src: ${src};`\n          }\n        }\n      })\n}\n\nexport function shouldEmbed(url: string): boolean {\n  return url.search(URL_REGEX) !== -1\n}\n\nexport async function embedResources(\n  cssText: string,\n  baseUrl: string | null,\n  options: Options,\n): Promise<string> {\n  if (!shouldEmbed(cssText)) {\n    return cssText\n  }\n\n  const filteredCSSText = filterPreferredFontFormat(cssText, options)\n  const urls = parseURLs(filteredCSSText)\n  return urls.reduce(\n    (deferred, url) =>\n      deferred.then((css) => embed(css, url, baseUrl, options)),\n    Promise.resolve(filteredCSSText),\n  )\n}\n","export function applyStyle(node, options) {\n    const { style } = node;\n    if (options.backgroundColor) {\n        style.backgroundColor = options.backgroundColor;\n    }\n    if (options.width) {\n        style.width = `${options.width}px`;\n    }\n    if (options.height) {\n        style.height = `${options.height}px`;\n    }\n    const manual = options.style;\n    if (manual != null) {\n        Object.keys(manual).forEach((key) => {\n            style[key] = manual[key];\n        });\n    }\n    return node;\n}\n//# sourceMappingURL=apply-style.js.map","import { Options } from './types'\n\nexport function applyStyle<T extends HTMLElement>(\n  node: T,\n  options: Options,\n): T {\n  const { style } = node\n\n  if (options.backgroundColor) {\n    style.backgroundColor = options.backgroundColor\n  }\n\n  if (options.width) {\n    style.width = `${options.width}px`\n  }\n\n  if (options.height) {\n    style.height = `${options.height}px`\n  }\n\n  const manual = options.style\n  if (manual != null) {\n    Object.keys(manual).forEach((key: any) => {\n      style[key] = manual[key] as string\n    })\n  }\n\n  return node\n}\n","import { toArray } from './util';\nimport { fetchAsDataURL } from './dataurl';\nimport { shouldEmbed, embedResources } from './embed-resources';\nconst cssFetchCache = {};\nasync function fetchCSS(url) {\n    let cache = cssFetchCache[url];\n    if (cache != null) {\n        return cache;\n    }\n    const res = await fetch(url);\n    const cssText = await res.text();\n    cache = { url, cssText };\n    cssFetchCache[url] = cache;\n    return cache;\n}\nasync function embedFonts(data, options) {\n    let cssText = data.cssText;\n    const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g;\n    const fontLocs = cssText.match(/url\\([^)]+\\)/g) || [];\n    const loadFonts = fontLocs.map(async (loc) => {\n        let url = loc.replace(regexUrl, '$1');\n        if (!url.startsWith('https://')) {\n            url = new URL(url, data.url).href;\n        }\n        return fetchAsDataURL(url, options.fetchRequestInit, ({ result }) => {\n            cssText = cssText.replace(loc, `url(${result})`);\n            return [loc, result];\n        });\n    });\n    return Promise.all(loadFonts).then(() => cssText);\n}\nfunction parseCSS(source) {\n    if (source == null) {\n        return [];\n    }\n    const result = [];\n    const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi;\n    // strip out comments\n    let cssText = source.replace(commentsRegex, '');\n    // eslint-disable-next-line prefer-regex-literals\n    const keyframesRegex = new RegExp('((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})', 'gi');\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const matches = keyframesRegex.exec(cssText);\n        if (matches === null) {\n            break;\n        }\n        result.push(matches[0]);\n    }\n    cssText = cssText.replace(keyframesRegex, '');\n    const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi;\n    // to match css & media queries together\n    const combinedCSSRegex = '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' +\n        '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})';\n    // unified regex\n    const unifiedRegex = new RegExp(combinedCSSRegex, 'gi');\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        let matches = importRegex.exec(cssText);\n        if (matches === null) {\n            matches = unifiedRegex.exec(cssText);\n            if (matches === null) {\n                break;\n            }\n            else {\n                importRegex.lastIndex = unifiedRegex.lastIndex;\n            }\n        }\n        else {\n            unifiedRegex.lastIndex = importRegex.lastIndex;\n        }\n        result.push(matches[0]);\n    }\n    return result;\n}\nasync function getCSSRules(styleSheets, options) {\n    const ret = [];\n    const deferreds = [];\n    // First loop inlines imports\n    styleSheets.forEach((sheet) => {\n        if ('cssRules' in sheet) {\n            try {\n                toArray(sheet.cssRules || []).forEach((item, index) => {\n                    if (item.type === CSSRule.IMPORT_RULE) {\n                        let importIndex = index + 1;\n                        const url = item.href;\n                        const deferred = fetchCSS(url)\n                            .then((metadata) => embedFonts(metadata, options))\n                            .then((cssText) => parseCSS(cssText).forEach((rule) => {\n                            try {\n                                sheet.insertRule(rule, rule.startsWith('@import')\n                                    ? (importIndex += 1)\n                                    : sheet.cssRules.length);\n                            }\n                            catch (error) {\n                                console.error('Error inserting rule from remote css', {\n                                    rule,\n                                    error,\n                                });\n                            }\n                        }))\n                            .catch((e) => {\n                            console.error('Error loading remote css', e.toString());\n                        });\n                        deferreds.push(deferred);\n                    }\n                });\n            }\n            catch (e) {\n                const inline = styleSheets.find((a) => a.href == null) || document.styleSheets[0];\n                if (sheet.href != null) {\n                    deferreds.push(fetchCSS(sheet.href)\n                        .then((metadata) => embedFonts(metadata, options))\n                        .then((cssText) => parseCSS(cssText).forEach((rule) => {\n                        inline.insertRule(rule, sheet.cssRules.length);\n                    }))\n                        .catch((err) => {\n                        console.error('Error loading remote stylesheet', err);\n                    }));\n                }\n                console.error('Error inlining remote css file', e);\n            }\n        }\n    });\n    return Promise.all(deferreds).then(() => {\n        // Second loop parses rules\n        styleSheets.forEach((sheet) => {\n            if ('cssRules' in sheet) {\n                try {\n                    toArray(sheet.cssRules || []).forEach((item) => {\n                        ret.push(item);\n                    });\n                }\n                catch (e) {\n                    console.error(`Error while reading CSS rules from ${sheet.href}`, e);\n                }\n            }\n        });\n        return ret;\n    });\n}\nfunction getWebFontRules(cssRules) {\n    return cssRules\n        .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)\n        .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')));\n}\nasync function parseWebFontRules(node, options) {\n    if (node.ownerDocument == null) {\n        throw new Error('Provided element is not within a Document');\n    }\n    const styleSheets = toArray(node.ownerDocument.styleSheets);\n    const cssRules = await getCSSRules(styleSheets, options);\n    return getWebFontRules(cssRules);\n}\nexport async function getWebFontCSS(node, options) {\n    const rules = await parseWebFontRules(node, options);\n    const cssTexts = await Promise.all(rules.map((rule) => {\n        const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;\n        return embedResources(rule.cssText, baseUrl, options);\n    }));\n    return cssTexts.join('\\n');\n}\nexport async function embedWebFonts(clonedNode, options) {\n    const cssText = options.fontEmbedCSS != null\n        ? options.fontEmbedCSS\n        : options.skipFonts\n            ? null\n            : await getWebFontCSS(clonedNode, options);\n    if (cssText) {\n        const styleNode = document.createElement('style');\n        const sytleContent = document.createTextNode(cssText);\n        styleNode.appendChild(sytleContent);\n        if (clonedNode.firstChild) {\n            clonedNode.insertBefore(styleNode, clonedNode.firstChild);\n        }\n        else {\n            clonedNode.appendChild(styleNode);\n        }\n    }\n}\n//# sourceMappingURL=embed-webfonts.js.map","import type { Options } from './types'\nimport { toArray } from './util'\nimport { fetchAsDataURL } from './dataurl'\nimport { shouldEmbed, embedResources } from './embed-resources'\n\ninterface Metadata {\n  url: string\n  cssText: string\n}\n\nconst cssFetchCache: { [href: string]: Metadata } = {}\n\nasync function fetchCSS(url: string) {\n  let cache = cssFetchCache[url]\n  if (cache != null) {\n    return cache\n  }\n\n  const res = await fetch(url)\n  const cssText = await res.text()\n  cache = { url, cssText }\n\n  cssFetchCache[url] = cache\n\n  return cache\n}\n\nasync function embedFonts(data: Metadata, options: Options): Promise<string> {\n  let cssText = data.cssText\n  const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g\n  const fontLocs = cssText.match(/url\\([^)]+\\)/g) || []\n  const loadFonts = fontLocs.map(async (loc: string) => {\n    let url = loc.replace(regexUrl, '$1')\n    if (!url.startsWith('https://')) {\n      url = new URL(url, data.url).href\n    }\n\n    return fetchAsDataURL<[string, string]>(\n      url,\n      options.fetchRequestInit,\n      ({ result }) => {\n        cssText = cssText.replace(loc, `url(${result})`)\n        return [loc, result]\n      },\n    )\n  })\n\n  return Promise.all(loadFonts).then(() => cssText)\n}\n\nfunction parseCSS(source: string) {\n  if (source == null) {\n    return []\n  }\n\n  const result: string[] = []\n  const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi\n  // strip out comments\n  let cssText = source.replace(commentsRegex, '')\n\n  // eslint-disable-next-line prefer-regex-literals\n  const keyframesRegex = new RegExp(\n    '((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})',\n    'gi',\n  )\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const matches = keyframesRegex.exec(cssText)\n    if (matches === null) {\n      break\n    }\n    result.push(matches[0])\n  }\n  cssText = cssText.replace(keyframesRegex, '')\n\n  const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi\n  // to match css & media queries together\n  const combinedCSSRegex =\n    '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' +\n    '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})'\n  // unified regex\n  const unifiedRegex = new RegExp(combinedCSSRegex, 'gi')\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let matches = importRegex.exec(cssText)\n    if (matches === null) {\n      matches = unifiedRegex.exec(cssText)\n      if (matches === null) {\n        break\n      } else {\n        importRegex.lastIndex = unifiedRegex.lastIndex\n      }\n    } else {\n      unifiedRegex.lastIndex = importRegex.lastIndex\n    }\n    result.push(matches[0])\n  }\n\n  return result\n}\n\nasync function getCSSRules(\n  styleSheets: CSSStyleSheet[],\n  options: Options,\n): Promise<CSSStyleRule[]> {\n  const ret: CSSStyleRule[] = []\n  const deferreds: Promise<number | void>[] = []\n\n  // First loop inlines imports\n  styleSheets.forEach((sheet) => {\n    if ('cssRules' in sheet) {\n      try {\n        toArray<CSSRule>(sheet.cssRules || []).forEach((item, index) => {\n          if (item.type === CSSRule.IMPORT_RULE) {\n            let importIndex = index + 1\n            const url = (item as CSSImportRule).href\n            const deferred = fetchCSS(url)\n              .then((metadata) => embedFonts(metadata, options))\n              .then((cssText) =>\n                parseCSS(cssText).forEach((rule) => {\n                  try {\n                    sheet.insertRule(\n                      rule,\n                      rule.startsWith('@import')\n                        ? (importIndex += 1)\n                        : sheet.cssRules.length,\n                    )\n                  } catch (error) {\n                    console.error('Error inserting rule from remote css', {\n                      rule,\n                      error,\n                    })\n                  }\n                }),\n              )\n              .catch((e) => {\n                console.error('Error loading remote css', e.toString())\n              })\n\n            deferreds.push(deferred)\n          }\n        })\n      } catch (e) {\n        const inline =\n          styleSheets.find((a) => a.href == null) || document.styleSheets[0]\n        if (sheet.href != null) {\n          deferreds.push(\n            fetchCSS(sheet.href)\n              .then((metadata) => embedFonts(metadata, options))\n              .then((cssText) =>\n                parseCSS(cssText).forEach((rule) => {\n                  inline.insertRule(rule, sheet.cssRules.length)\n                }),\n              )\n              .catch((err: unknown) => {\n                console.error('Error loading remote stylesheet', err)\n              }),\n          )\n        }\n        console.error('Error inlining remote css file', e)\n      }\n    }\n  })\n\n  return Promise.all(deferreds).then(() => {\n    // Second loop parses rules\n    styleSheets.forEach((sheet) => {\n      if ('cssRules' in sheet) {\n        try {\n          toArray<CSSStyleRule>(sheet.cssRules || []).forEach((item) => {\n            ret.push(item)\n          })\n        } catch (e) {\n          console.error(`Error while reading CSS rules from ${sheet.href}`, e)\n        }\n      }\n    })\n\n    return ret\n  })\n}\n\nfunction getWebFontRules(cssRules: CSSStyleRule[]): CSSStyleRule[] {\n  return cssRules\n    .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)\n    .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')))\n}\n\nasync function parseWebFontRules<T extends HTMLElement>(\n  node: T,\n  options: Options,\n) {\n  if (node.ownerDocument == null) {\n    throw new Error('Provided element is not within a Document')\n  }\n\n  const styleSheets = toArray<CSSStyleSheet>(node.ownerDocument.styleSheets)\n  const cssRules = await getCSSRules(styleSheets, options)\n\n  return getWebFontRules(cssRules)\n}\n\nexport async function getWebFontCSS<T extends HTMLElement>(\n  node: T,\n  options: Options,\n): Promise<string> {\n  const rules = await parseWebFontRules(node, options)\n  const cssTexts = await Promise.all(\n    rules.map((rule) => {\n      const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null\n      return embedResources(rule.cssText, baseUrl, options)\n    }),\n  )\n\n  return cssTexts.join('\\n')\n}\n\nexport async function embedWebFonts<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const cssText =\n    options.fontEmbedCSS != null\n      ? options.fontEmbedCSS\n      : options.skipFonts\n      ? null\n      : await getWebFontCSS(clonedNode, options)\n\n  if (cssText) {\n    const styleNode = document.createElement('style')\n    const sytleContent = document.createTextNode(cssText)\n\n    styleNode.appendChild(sytleContent)\n\n    if (clonedNode.firstChild) {\n      clonedNode.insertBefore(styleNode, clonedNode.firstChild)\n    } else {\n      clonedNode.appendChild(styleNode)\n    }\n  }\n}\n","(function(a,b){if(\"function\"==typeof define&&define.amd)define([],b);else if(\"undefined\"!=typeof exports)b();else{b(),a.FileSaver={exports:{}}.exports}})(this,function(){\"use strict\";function b(a,b){return\"undefined\"==typeof b?b={autoBom:!1}:\"object\"!=typeof b&&(console.warn(\"Deprecated: Expected third argument to be a object\"),b={autoBom:!b}),b.autoBom&&/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(a.type)?new Blob([\"\\uFEFF\",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open(\"GET\",a),d.responseType=\"blob\",d.onload=function(){g(d.response,b,c)},d.onerror=function(){console.error(\"could not download file\")},d.send()}function d(a){var b=new XMLHttpRequest;b.open(\"HEAD\",a,!1);try{b.send()}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent(\"click\"))}catch(c){var b=document.createEvent(\"MouseEvents\");b.initMouseEvent(\"click\",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f=\"object\"==typeof window&&window.window===window?window:\"object\"==typeof self&&self.self===self?self:\"object\"==typeof global&&global.global===global?global:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||(\"object\"!=typeof window||window!==f?function(){}:\"download\"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement(\"a\");g=g||b.name||\"download\",j.download=g,j.rel=\"noopener\",\"string\"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target=\"_blank\")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:\"msSaveOrOpenBlob\"in navigator?function(f,g,h){if(g=g||f.name||\"download\",\"string\"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement(\"a\");i.href=f,i.target=\"_blank\",setTimeout(function(){e(i)})}}:function(b,d,e,g){if(g=g||open(\"\",\"_blank\"),g&&(g.document.title=g.document.body.innerText=\"downloading...\"),\"string\"==typeof b)return c(b,d,e);var h=\"application/octet-stream\"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\\/[\\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&\"undefined\"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,\"data:attachment/file;\"),g?g.location.href=a:location=a,g=null},k.readAsDataURL(b)}else{var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m)},4E4)}});f.saveAs=g.saveAs=g,\"undefined\"!=typeof module&&(module.exports=g)});\n\n//# sourceMappingURL=FileSaver.min.js.map","/*\n* FileSaver.js\n* A saveAs() FileSaver implementation.\n*\n* By Eli Grey, http://eligrey.com\n*\n* License : https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md (MIT)\n* source  : http://purl.eligrey.com/github/FileSaver.js\n*/\n\n// The one and only way of getting global scope in all environments\n// https://stackoverflow.com/q/3277182/1008999\nvar _global = typeof window === 'object' && window.window === window\n  ? window : typeof self === 'object' && self.self === self\n  ? self : typeof global === 'object' && global.global === global\n  ? global\n  : this\n\nfunction bom (blob, opts) {\n  if (typeof opts === 'undefined') opts = { autoBom: false }\n  else if (typeof opts !== 'object') {\n    console.warn('Deprecated: Expected third argument to be a object')\n    opts = { autoBom: !opts }\n  }\n\n  // prepend BOM for UTF-8 XML and text/* types (including HTML)\n  // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n  if (opts.autoBom && /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n    return new Blob([String.fromCharCode(0xFEFF), blob], { type: blob.type })\n  }\n  return blob\n}\n\nfunction download (url, name, opts) {\n  var xhr = new XMLHttpRequest()\n  xhr.open('GET', url)\n  xhr.responseType = 'blob'\n  xhr.onload = function () {\n    saveAs(xhr.response, name, opts)\n  }\n  xhr.onerror = function () {\n    console.error('could not download file')\n  }\n  xhr.send()\n}\n\nfunction corsEnabled (url) {\n  var xhr = new XMLHttpRequest()\n  // use sync to avoid popup blocker\n  xhr.open('HEAD', url, false)\n  try {\n    xhr.send()\n  } catch (e) {}\n  return xhr.status >= 200 && xhr.status <= 299\n}\n\n// `a.click()` doesn't work for all browsers (#465)\nfunction click (node) {\n  try {\n    node.dispatchEvent(new MouseEvent('click'))\n  } catch (e) {\n    var evt = document.createEvent('MouseEvents')\n    evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80,\n                          20, false, false, false, false, 0, null)\n    node.dispatchEvent(evt)\n  }\n}\n\n// Detect WebView inside a native macOS app by ruling out all browsers\n// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too\n// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos\nvar isMacOSWebView = _global.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent)\n\nvar saveAs = _global.saveAs || (\n  // probably in some web worker\n  (typeof window !== 'object' || window !== _global)\n    ? function saveAs () { /* noop */ }\n\n  // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView\n  : ('download' in HTMLAnchorElement.prototype && !isMacOSWebView)\n  ? function saveAs (blob, name, opts) {\n    var URL = _global.URL || _global.webkitURL\n    var a = document.createElement('a')\n    name = name || blob.name || 'download'\n\n    a.download = name\n    a.rel = 'noopener' // tabnabbing\n\n    // TODO: detect chrome extensions & packaged apps\n    // a.target = '_blank'\n\n    if (typeof blob === 'string') {\n      // Support regular links\n      a.href = blob\n      if (a.origin !== location.origin) {\n        corsEnabled(a.href)\n          ? download(blob, name, opts)\n          : click(a, a.target = '_blank')\n      } else {\n        click(a)\n      }\n    } else {\n      // Support blobs\n      a.href = URL.createObjectURL(blob)\n      setTimeout(function () { URL.revokeObjectURL(a.href) }, 4E4) // 40s\n      setTimeout(function () { click(a) }, 0)\n    }\n  }\n\n  // Use msSaveOrOpenBlob as a second approach\n  : 'msSaveOrOpenBlob' in navigator\n  ? function saveAs (blob, name, opts) {\n    name = name || blob.name || 'download'\n\n    if (typeof blob === 'string') {\n      if (corsEnabled(blob)) {\n        download(blob, name, opts)\n      } else {\n        var a = document.createElement('a')\n        a.href = blob\n        a.target = '_blank'\n        setTimeout(function () { click(a) })\n      }\n    } else {\n      navigator.msSaveOrOpenBlob(bom(blob, opts), name)\n    }\n  }\n\n  // Fallback to using FileReader and a popup\n  : function saveAs (blob, name, opts, popup) {\n    // Open a popup immediately do go around popup blocker\n    // Mostly only available on user interaction and the fileReader is async so...\n    popup = popup || open('', '_blank')\n    if (popup) {\n      popup.document.title =\n      popup.document.body.innerText = 'downloading...'\n    }\n\n    if (typeof blob === 'string') return download(blob, name, opts)\n\n    var force = blob.type === 'application/octet-stream'\n    var isSafari = /constructor/i.test(_global.HTMLElement) || _global.safari\n    var isChromeIOS = /CriOS\\/[\\d]+/.test(navigator.userAgent)\n\n    if ((isChromeIOS || (force && isSafari) || isMacOSWebView) && typeof FileReader !== 'undefined') {\n      // Safari doesn't allow downloading of blob URLs\n      var reader = new FileReader()\n      reader.onloadend = function () {\n        var url = reader.result\n        url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, 'data:attachment/file;')\n        if (popup) popup.location.href = url\n        else location = url\n        popup = null // reverse-tabnabbing #460\n      }\n      reader.readAsDataURL(blob)\n    } else {\n      var URL = _global.URL || _global.webkitURL\n      var url = URL.createObjectURL(blob)\n      if (popup) popup.location = url\n      else location.href = url\n      popup = null // reverse-tabnabbing #460\n      setTimeout(function () { URL.revokeObjectURL(url) }, 4E4) // 40s\n    }\n  }\n)\n\n_global.saveAs = saveAs.saveAs = saveAs\n\nif (typeof module !== 'undefined') {\n  module.exports = saveAs;\n}\n"],"names":["b","$cfae44f0dfdf62c0$var$cachedSetTimeout","$cfae44f0dfdf62c0$var$cachedClearTimeout","$cfae44f0dfdf62c0$var$currentQueue","$parcel$global","globalThis","$cfae44f0dfdf62c0$exports","$cfae44f0dfdf62c0$var$process","$cfae44f0dfdf62c0$var$defaultSetTimout","Error","$cfae44f0dfdf62c0$var$defaultClearTimeout","$cfae44f0dfdf62c0$var$runTimeout","fun","setTimeout","e","call","clearTimeout","$cfae44f0dfdf62c0$var$queue","$cfae44f0dfdf62c0$var$draining","$cfae44f0dfdf62c0$var$queueIndex","$cfae44f0dfdf62c0$var$cleanUpNextTick","length","concat","$cfae44f0dfdf62c0$var$drainQueue","timeout","len","run","$cfae44f0dfdf62c0$var$runClearTimeout","marker","$cfae44f0dfdf62c0$var$Item","array","$cfae44f0dfdf62c0$var$noop","nextTick","args","Array","arguments","i","push","prototype","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","$9eb70742a7095e98$export$31b40729666a4ae0","counter","random","Math","toString","slice","$9eb70742a7095e98$export$45b10814cc054894","arrayLike","arr","l","$9eb70742a7095e98$var$px","node","styleProperty","val","win","ownerDocument","defaultView","window","getComputedStyle","getPropertyValue","parseFloat","replace","$9eb70742a7095e98$export$ada5537b2c061996","targetNode","options","width","$9eb70742a7095e98$var$getNodeWidth","leftBorder","rightBorder","clientWidth","height","$9eb70742a7095e98$var$getNodeHeight","topBorder","bottomBorder","clientHeight","$9eb70742a7095e98$export$ec664d7487540b","url","Promise","resolve","reject","img","Image","decode","onload","onerror","crossOrigin","decoding","src","$9eb70742a7095e98$export$fe77aa9c02de4599","svg","then","XMLSerializer","serializeToString","encodeURIComponent","html","$9eb70742a7095e98$export$b62810fb8ca515fa","xmlns","document","createElementNS","foreignObject","setAttribute","appendChild","$9eb70742a7095e98$export$3a92fc9ec83ef360","instance","nodePrototype","Object","getPrototypeOf","constructor","$f1d3d4da19ace37e$var$clonePseudoElement","nativeNode","clonedNode","pseudo","style","content","className","err","styleElement","createElement","$f1d3d4da19ace37e$var$getPseudoElementStyle","selector","cssText","$f1d3d4da19ace37e$var$formatCSSText","map","value","priority","getPropertyPriority","join","createTextNode","$67e830aaea99e7b5$var$WOFF","$67e830aaea99e7b5$var$JPEG","$67e830aaea99e7b5$var$mimes","woff","woff2","ttf","eot","png","jpg","jpeg","gif","tiff","webp","$67e830aaea99e7b5$export$200548c990602f61","$67e830aaea99e7b5$var$getExtension","match","exec","toLowerCase","$fd9aaa441bfc2baf$export$f8a05efa20ffd5a","search","$fd9aaa441bfc2baf$export$68336ea1617fa80a","mimeType","$fd9aaa441bfc2baf$export$c20a8b76c95b0d41","init","process","res","fetch","status","blob","reader","FileReader","onloadend","result","error","readAsDataURL","$fd9aaa441bfc2baf$var$cache","$fd9aaa441bfc2baf$export$bdf0422c029b202a","resourceUrl","contentType","includeQueryParams","dataURL","key","cacheKey","test","cacheBust","Date","getTime","fetchRequestInit","headers","get","split","imagePlaceholder","msg","message","console","warn","$dc746d806551912c$var$cloneCanvasElement","canvas","toDataURL","cloneNode","$dc746d806551912c$var$cloneVideoElement","video","currentSrc","ctx","getContext","drawImage","poster","$dc746d806551912c$var$cloneIFrameElement","iframe","_a","contentDocument","body","$dc746d806551912c$export$ae8e35ea29ddac22","_b","$dc746d806551912c$var$cloneSingleNode","HTMLCanvasElement","HTMLVideoElement","HTMLIFrameElement","$dc746d806551912c$var$isSlotElement","tagName","toUpperCase","$dc746d806551912c$var$cloneChildren","children","assignedNodes","childNodes","shadowRoot","reduce","deferred","child","clonedChild","$dc746d806551912c$var$ensureSVGSymbols","clone","uses","querySelectorAll","processedDefs","id","use","getAttribute","exist","querySelector","definition","nodes","values","ns","position","overflow","display","defs","isRoot","filter","Element","$dc746d806551912c$var$cloneCSSStyle","targetStyle","sourceStyle","transformOrigin","forEach","endsWith","reducedFont","floor","substring","setProperty","HTMLTextAreaElement","innerHTML","HTMLInputElement","$dc746d806551912c$var$cloneSelectValue","HTMLSelectElement","selectedOption","from","clonedSelect","find","$8cc1ee3e9af11276$var$URL_REGEX","$8cc1ee3e9af11276$var$URL_WITH_FORMAT_REGEX","$8cc1ee3e9af11276$var$FONT_SRC_REGEX","$8cc1ee3e9af11276$export$2be46bb7e96db87f","resourceURL","baseURL","getContentFromUrl","resolvedURL","baseUrl","location","protocol","doc","implementation","createHTMLDocument","base","a","head","href","$8cc1ee3e9af11276$var$toRegex","escaped","RegExp","$8cc1ee3e9af11276$export$7b668369e5eab853","$8cc1ee3e9af11276$export$3d88803585cbbc21","filteredCSSText","$8cc1ee3e9af11276$var$filterPreferredFontFormat","str","preferredFontFormat","format","urls","$8cc1ee3e9af11276$export$d04549d631b8762d","raw","quotation","css","$5938d0f1526f12ac$var$embedProp","propName","propValue","cssString","$5938d0f1526f12ac$var$embedBackground","$5938d0f1526f12ac$var$embedImageNode","isImageElement","HTMLImageElement","SVGImageElement","baseVal","image","loading","srcset","$5938d0f1526f12ac$var$embedChildren","deferreds","$5938d0f1526f12ac$export$6660fa8dd20e53aa","all","$673cafb05cbd0034$var$cssFetchCache","$673cafb05cbd0034$var$fetchCSS","cache","text","$673cafb05cbd0034$var$embedFonts","data","regexUrl","fontLocs","loc","startsWith","URL","$673cafb05cbd0034$var$parseCSS","source","keyframesRegex","matches","importRegex","unifiedRegex","lastIndex","$673cafb05cbd0034$var$getCSSRules","styleSheets","ret","sheet","cssRules","item","index","type","CSSRule","IMPORT_RULE","importIndex","metadata","rule","insertRule","catch","inline","$673cafb05cbd0034$var$parseWebFontRules","FONT_FACE_RULE","$673cafb05cbd0034$export$253c9aa3d83a57b6","rules","cssTexts","parentStyleSheet","$673cafb05cbd0034$export$2c2c83b77c8cb421","fontEmbedCSS","skipFonts","styleNode","sytleContent","firstChild","insertBefore","$8fb130f5e2a07b68$export$20d300cb2d558b7","backgroundColor","manual","keys","$8fb130f5e2a07b68$export$f87f6982d1fd4f81","context","ratio","pixelRatio","FINAL_PROCESS","devicePixelRatio","Number","isNaN","parseInt","canvasWidth","canvasHeight","skipAutoScale","$9eb70742a7095e98$var$canvasDimensionLimit","fillStyle","fillRect","$8fb130f5e2a07b68$export$aba256f33615c92e","$90f256c567e4c320$exports","c","d","XMLHttpRequest","open","responseType","g","response","send","dispatchEvent","MouseEvent","createEvent","initMouseEvent","f","self","global","navigator","userAgent","saveAs","HTMLAnchorElement","h","webkitURL","j","download","rel","origin","target","createObjectURL","revokeObjectURL","msSaveOrOpenBlob","autoBom","Blob","innerText","HTMLElement","safari","k","m","define","amd","buttonEl","getElementsByTagName","textareaEl","outputSection","outputTextEl","getElementById","convertElementToImage","element","dataUrl","addEventListener","memeText","makeAlternatingCase","alternateCaseText","textContent","log"],"version":3,"file":"index.ce9b5ce0.js.map"}